[{"id":"\/docs\/html\/overview\/prooph-in-a-nutshell.html#1-1","title":"prooph in a nutshell","content":""},{"id":"\/docs\/html\/overview\/components.html#1-2-1","title":"prooph\/common","content":"Common classes shared between prooph componentsprooph\/common"},{"id":"\/docs\/html\/overview\/components.html#1-2-2","title":"Prooph Service Bus (PSB)","content":"PHP 7.1+ lightweight message bus supporting CQRS and Micro Servicesprooph\/service-bushttps:\/\/github.com\/prooph\/psb-http-producer"},{"id":"\/docs\/html\/overview\/components.html#1-2-2-1","title":"HTTP Message Producer","content":"prooph\/psb-http-producer for prooph\/service-bus."},{"id":"\/docs\/html\/overview\/components.html#1-2-2-2","title":"HumusAMQP Message Producer","content":"prooph\/humus-amqp-producer for prooph\/service-bus."},{"id":"\/docs\/html\/overview\/components.html#1-2-2-3","title":"Bernard Message Producer","content":"prooph\/psb-bernard-producer for prooph\/service-bus."},{"id":"\/docs\/html\/overview\/components.html#1-2-2-4","title":"ZeroMQ Message Producer","content":"prooph\/psb-zeromq-producer for prooph\/service-bus."},{"id":"\/docs\/html\/overview\/components.html#1-2-2-5","title":"Service Bus ZfcRbac Bridge","content":"prooph\/service-bus-zfc-rbac-bridge for prooph\/service-bus"},{"id":"\/docs\/html\/overview\/components.html#1-2-3","title":"Prooph Event Store","content":"ProophEventStore is capable of persisting event objects that are organized in streams.prooph\/event-store"},{"id":"\/docs\/html\/overview\/components.html#1-2-3-1","title":"Event Store HTTP API","content":"prooph\/event-store-http-api"},{"id":"\/docs\/html\/overview\/components.html#1-2-3-2","title":"PDO Event Store","content":"prooph\/pdo-event-store"},{"id":"\/docs\/html\/overview\/components.html#1-2-3-3","title":"Redis Event Store","content":"prooph\/redis-event-store"},{"id":"\/docs\/html\/overview\/components.html#1-2-4","title":"Snapshotter","content":"Take aggregate snapshots with easeprooph\/snapshotter"},{"id":"\/docs\/html\/overview\/components.html#1-2-5","title":"Snapshot Store","content":"prooph\/snapshot-store"},{"id":"\/docs\/html\/overview\/components.html#1-2-5-1","title":"MongoDB Snapshot Store","content":"prooph\/mongodb-snapshot-store"},{"id":"\/docs\/html\/overview\/components.html#1-2-5-2","title":"PDO Snapshot Store","content":"prooph\/pdo-snapshot-store"},{"id":"\/docs\/html\/overview\/components.html#1-2-5-3","title":"ArangoDB Snapshot Store","content":"prooph\/arangodb-snapshot-store"},{"id":"\/docs\/html\/overview\/components.html#1-2-5-4","title":"Memcached Snapshot Store","content":"prooph\/memcached-snapshot-store"},{"id":"\/docs\/html\/overview\/components.html#1-2-6","title":"Projections","content":"A set of standard projectionsprooph\/standard-projections"},{"id":"\/docs\/html\/overview\/components.html#1-2-7","title":"Prooph Event Sourcing","content":"Simple and lightweight event sourcing library with out of the box support for prooph\/event-store.prooph\/event-sourcing"},{"id":"\/docs\/html\/overview\/components.html#1-2-8","title":"prooph\/event-store-bus-bridge","content":"Glue component between prooph\/service-bus and prooph\/event-storeprooph\/event-store-bus-bridge"},{"id":"\/docs\/html\/overview\/components.html#1-2-9","title":"Annotations Support","content":"Reduce boilerplate by using prooph annotations.prooph\/annotations"},{"id":"\/docs\/html\/overview\/components.html#1-2-10","title":"Symfony Integration","content":"prooph\/service-bus-symfony-bundleprooph\/event-store-symfony-bundleprooph\/event-store-bus-bridge-symfony-bundle"},{"id":"\/docs\/html\/overview\/components.html#1-2-11","title":"Laravel Integration","content":"prooph\/laravel-package"},{"id":"\/docs\/html\/overview\/components.html#1-2-12-1","title":"prooph micro","content":"Functional php and prooph for Microservicesprooph\/micro"},{"id":"\/docs\/html\/overview\/components.html#1-2-12-2","title":"prooph micro-cli","content":"Command line tool to manage prooph micro servicesprooph\/micro-cli"},{"id":"\/docs\/html\/overview\/components.html#1-2-13","title":"prooph Docker images","content":"Used in our examples apps and for prooph\/micro-cliprooph\/docker-files"},{"id":"\/docs\/html\/overview\/components.html#1-2-14","title":"PSR Middleware Support","content":"prooph\/psr7-middleware"},{"id":"\/docs\/html\/overview\/components.html#1-2-15-1","title":"proophessor-do","content":"Uses zend-expressive as web layer and contains additional tutorialsprooph\/proophessor-do"},{"id":"\/docs\/html\/overview\/components.html#1-2-15-2","title":"proophessor-do-symfony","content":"Symfony version of proophessor-doprooph\/proophessor-do-symfony"},{"id":"\/docs\/html\/overview\/components.html#1-2-15-3","title":"prooph micro-do","content":"prooph micro version of proophessor-doprooph\/micro-do"},{"id":"\/docs\/html\/service-bus\/intro.html#2-1","title":"PSB - ProophServiceBus","content":"PHP 7.1+ lightweight message bus supporting CQRS and Micro Services "},{"id":"\/docs\/html\/service-bus\/intro.html#2-1-1","title":"Messaging API","content":"prooph\/service-bus is a lightweight messaging facade. It allows you to define the API of your model with the help of messages. Command messages describe actions your model can handle. Event messages describe things that happened while your model handled a command. Query messages describe available information that can be fetched from your (read) model. prooph\/service-bus shields your model. Data input and output ports become irrelevant and no longer influence business logic. We're looking at you Hexagonal Architecture.prooph\/service-bus decouples your model from any framework. You can use a web framework like Zend, Symfony, Laravel and co. to handle http requests and pass them via prooph\/service-bus to your model but you can also receive the same messages via CLI or from a messaging system like RabbitMQ or Beanstalkd.It is also a perfect fit for microservices architecture as it provides an abstraction layer for message-based inter-service communication."},{"id":"\/docs\/html\/service-bus\/intro.html#2-1-2","title":"Installation","content":"You can install prooph\/service-bus via composer by adding \"prooph\/service-bus\": \"~5.0\" as requirement to your composer.json."},{"id":"\/docs\/html\/service-bus\/intro.html#2-1-3","title":"Quick Start","content":"&lt;?php use Prooph\\ServiceBus\\CommandBus; use Prooph\\ServiceBus\\Example\\Command\\EchoText; use Prooph\\ServiceBus\\Plugin\\Router\\CommandRouter; $commandBus = new CommandBus(); $router = new CommandRouter(); \/\/Register a callback as CommandHandler for the EchoText command $router-&gt;route('Prooph\\ServiceBus\\Example\\Command\\EchoText') -&gt;to(function (EchoText $aCommand): void { echo $aCommand-&gt;getText(); }); \/\/Expand command bus with the router plugin $router-&gt;attachToMessageBus($commandBus); \/\/We create a new Command $echoText = new EchoText('It works'); \/\/... and dispatch it $commandBus-&gt;dispatch($echoText); \/\/Output should be: It works "},{"id":"\/docs\/html\/service-bus\/intro.html#2-1-4","title":"Documentation","content":"Documentation is in the docs tree, and can be compiled using bookdown.$ php .\/vendor\/bin\/bookdown docs\/bookdown.json $ php -S 0.0.0.0:8080 -t docs\/html\/ Then browse to http:\/\/localhost:8080\/"},{"id":"\/docs\/html\/service-bus\/intro.html#2-1-5","title":"Support","content":" Ask questions on prooph-users google group. File issues at https:\/\/github.com\/prooph\/service-bus\/issues. Say hello in the prooph gitter chat. "},{"id":"\/docs\/html\/service-bus\/intro.html#2-1-6","title":"Contribute","content":"Please feel free to fork and extend existing or add new features and send a pull request with your changes! To establish a consistent code quality, please provide unit tests for all your changes and may adapt the documentation."},{"id":"\/docs\/html\/service-bus\/intro.html#2-1-7","title":"License","content":"Released under the New BSD License."},{"id":"\/docs\/html\/service-bus\/overview.html#2-2","title":"PSB Overview","content":"prooph\/service-bus acts as a messaging facade. It operates on application layer and shields your domain model. In addition we also provide so called \"message producers\" which connect prooph\/service-bus with messaging infrastructure on system and network level.Three different message bus implementations are available."},{"id":"\/docs\/html\/service-bus\/overview.html#2-2-1","title":"CommandBus","content":"The CommandBus is designed to dispatch a message to only one handler or message producer. It does not return a result. Sending a command means fire and forget and enforces the Tell-Don't-Ask principle."},{"id":"\/docs\/html\/service-bus\/overview.html#2-2-2","title":"EventBus","content":"The EventBus is able to dispatch a message to n listeners. Each listener can be a message handler or message producer. Like commands the EventBus doesn't return anything."},{"id":"\/docs\/html\/service-bus\/overview.html#2-2-3","title":"QueryBus","content":"The QueryBus also dispatches a message to only one finder (special query message handler) but it returns a React\\Promise\\Promise. The QueryBus hands over the query message to a finder but also a React\\Promise\\Deferred which needs to be resolved by the finder. We use promises to allow finders to handle queries asynchronous for example using curl_multi_exec."},{"id":"\/docs\/html\/service-bus\/overview.html#2-2-4","title":"Message Objects","content":"You are free to use your own message objects (or even primitive types if you want). All message buses are smart enough to handle them. If you need custom logic to handle your messages check out the list of available message bus plugins or write your own bus plugin. It is pretty straight forward."},{"id":"\/docs\/html\/service-bus\/overview.html#2-2","title":"Synchronous Versus Asynchronous Processing","content":"PSB provides both possibilities behind a unified interface. Remember the statement \"Messaging means fire and forget\". The callee never knows if the message is processed synchronous or asynchronous. A message can directly be routed to it's handler. In this case we talk about synchronous message processing. If the message is routed to message producer it is normally processed asynchronous."},{"id":"\/docs\/html\/service-bus\/message_bus.html#2-3-1","title":"Commanding","content":"When you want to apply CQRS the command bus is your best friend. It takes an incoming command message and routes it to the responsible command handler. The advantage of using a CommandBus instead of calling command handlers directly is, that you can change your model without effecting the application logic. You can work with command versions to dispatch a newer version to a new command handler and older versions to old command handlers. Your model can support different versions at the same time which makes migrations a lot easier. Second feature of a command bus could be automatic transaction handling. And for distributed systems it is also interesting to push the command on a queue and handle it asynchronous."},{"id":"\/docs\/html\/service-bus\/message_bus.html#2-3-2","title":"Eventing","content":"When dividing your domain logic into modules or bounded contexts you need a way to inform the outside world about events that happened in your model. An EventBus is responsible for dispatching event messages to all interested listeners. If a listener is part of another system the event may need to be send to a remote interface."},{"id":"\/docs\/html\/service-bus\/message_bus.html#2-3-3","title":"Querying","content":"A system based on Microservices requires a lightweight communication channel. The two most used protocols are HTTP request-response with resource API's and lightweight messaging. The latter is supported by prooph\/service-bus out-of-the-box but HTTP API's can be integrated too. The QueryBus is responsible for routing a query message to a so called finder. The query indicates that the producer expects a response. The finder's responsibility is to fetch data from a data source using the query parameters defined in the query message. It is up to the finder if the data is fetched synchronous or asynchronous, so the QueryBus returns a React\\Promise\\Promise to the callee."},{"id":"\/docs\/html\/service-bus\/message_bus.html#2-3-4","title":"API","content":"All three bus types extend the same base class Prooph\\ServiceBus\\MessageBus and therefore make use of an event-driven message dispatch process. Take a look at the CommandBus API. It is the same for EventBus and QueryBus except that the QueryBus returns a promise from QueryBus::dispatch.class CommandBus extends MessageBus { public function attach(string $eventName, callable $listener, int $priority = 0): ListenerHandler public function detach(ListenerHandler $handler): void \/** * @param mixed $command * * @throws CommandDispatchException *\/ public function dispatch($command): void; } The public API of a message bus is very simple. You can attach and detach plugins which are simple event listener aggregates and you can dispatch a message."},{"id":"\/docs\/html\/service-bus\/message_bus.html#2-3-5","title":"Event-Driven Dispatch","content":"Internally a prooph message bus uses an event-driven process to dispatch messages. This offers a lot of flexibility without the need to define interfaces for messages. A message can be everything even a string. prooph\/service-bus doesn't care. But using some defaults will reduce the number of required plugins and increase performance.But first let's take a look at the internals of a message dispatch process and the differences between the bus types."},{"id":"\/docs\/html\/service-bus\/message_bus.html#2-3-5-1","title":"dispatch","content":"This action event is triggered right after MessageBus::dispatch($message) is invoked.The following default priorities are integrated:public const PRIORITY_INITIALIZE = 400000; public const PRIORITY_DETECT_MESSAGE_NAME = 300000; public const PRIORITY_ROUTE = 200000; public const PRIORITY_LOCATE_HANDLER = 100000; public const PRIORITY_INVOKE_HANDLER = 0; "},{"id":"\/docs\/html\/service-bus\/message_bus.html#2-3-5-1-1","title":"initialize","content":"At this time the action event only contains the message. You can attach any listeners for initialization."},{"id":"\/docs\/html\/service-bus\/message_bus.html#2-3-5-1-2","title":"detect-message-name","content":"Before a message handler can be located, the message bus needs to know how the message is named. Their are two possibilities to provide the information. The message can implement the Prooph\\Common\\Messaging\\HasMessageName interface. In this case the message bus picks the name directly from the message and set it as param message-name in the action event for later use. The detect-message-name event is not triggered. If the message does not implement the interface the detect-message-name priority can be used to add a plugin to inject the name using ActionEvent::setParam('message-name', $messageName). If no message-name was set by a listener the message bus uses a fallback: FQCN of message in case of object message =&gt; message-name in case of string gettype($message) in all other cases "},{"id":"\/docs\/html\/service-bus\/message_bus.html#2-3-5-1-3","title":"route","content":"During the route phase a plugin (typically a router) should provide the responsible message handler either in form of a ready to use callable, an object or just a string. The latter should be a service id that can be passed to a service locator to get an instance of the message handler. The message handler should be set as action event param message-handler (for CommandBus and QueryBus) or event-listeners (for EventBus).As you can see command and query bus work with a single message handler whereby the event bus works with multiple listeners. This is one of the most important differences. Only the event bus allows multiple message handlers per message and therefor uses a slightly different dispatch process."},{"id":"\/docs\/html\/service-bus\/message_bus.html#2-3-5-1-4","title":"locate-handler","content":"After routing the message, the message bus checks if the handler was provided as a string. This is the latest time to provide an object or callable as message handler. If no plugin was able to provide one the message bus throws an exception."},{"id":"\/docs\/html\/service-bus\/message_bus.html#2-3-5-1-5","title":"invoke-handler","content":"Having the message handler in place it's time to invoke it with the message. callable message handlers are invoked by the bus. However, the invoke-handler \/ invoke-finder events are always triggered. At this stage all three bus types behave a bit different. CommandBus: invokes the handler with the command message. A invoke-handler event is triggered. QueryBus: much the same as the command bus but the message handler is invoked with the query message and a React\\Promise\\Deferred that needs to be resolved by the message handler aka finder. The query bus triggers a invoke-finder action event to indicate that a finder should be invoked and not a normal message handler. EventBus: loops over all event-listeners and triggers the locate-handler and invoke-handler action events for each message listener. *Note: * The command and query bus have a mechanism to check if the command or query was handled. If not they throw an exception. The event bus does not have such a mechanism as having no listener for an event is a valid case."},{"id":"\/docs\/html\/service-bus\/message_bus.html#2-3-5-2","title":"finalize","content":"This action event is always triggered at the end of the process no matter if the process was successful or an exception was thrown. It is the ideal place to attach a monitoring plugin.If at any time a plugin or the message bus itself throws an exception it is caught and passed as param exception to this action event. The normal action event chain breaks and a finalize event is triggered instead. Plugins can then access the exception by getting it from the action event. A finalize plugin can unset the exception by calling ActionEvent::setParam(\"exception\", null). When all plugins are informed about the error and no one has unset the exception the message bus throws a Prooph\\ServiceBus\\Exception\\MessageDispatchException to inform the outside world about the error.Note: The query bus has another additional priority PRIORITY_PROMISE_REJECT which is used to reject the promise in case of an exception during the finalize event. If you want to remove the exception with a listener, you need to add your listener with a higher priority than that."},{"id":"\/docs\/html\/service-bus\/message_bus.html#2-3-6-1","title":"Events &amp; Priorities","content":"Two things are to consider, when upgrading from v5. The handle-error event is gone. If you want to have a plugin that tracks exception, you need to use the finalize event and check for existence of an exception. This can look like this: $commandBus-&gt;attach( CommandBus::EVENT_FINALIZE, function (ActionEvent $actionEvent) { if ($ex = $actionEvent-&gt;getParam(CommandBus::EVENT_PARAM_EXCEPTION) { \/\/ do something } } );  There is a new dispatch event replacing all other previously existing events. It is controlled by event priorities instead. So if your previous plugin looked like this: $commandBus-&gt;attach( CommandBus::EVENT_INVOKE_HANDLER, function (ActionEvent $actionEvent) { if ($ex = $actionEvent-&gt;getParam(CommandBus::EVENT_PARAM_EXCEPTION) { \/\/ do something } } ); it now has to look like this:$commandBus-&gt;attach( CommandBus::EVENT_DISPATCH, function (ActionEvent $actionEvent) { if ($ex = $actionEvent-&gt;getParam(CommandBus::EVENT_PARAM_EXCEPTION) { \/\/ do something } }, CommandBus::PRIORITY_INVOKE_HANDLER );  Attaching to ActionEvents Instead of calling:$commandBus -&gt;getActionEventEmitter() -&gt;attachListener(string $event, callable $listener, int $priority = 1): ListenerHandler; It's more simple now:$commandBus-&gt;attach(string $event, callable $listener, int $priority = 1): ListenerHandler;  Plugins Instead of implementing Prooph\\Common\\Event\\ActionEventListenerAggregate a plugin now has to implement Prooph\\ServiceBus\\Plugin\\Plugin. The signature is:public function attachToMessageBus(MessageBus $messageBus): void; public function detachFromMessageBus(MessageBus $messageBus): void; "},{"id":"\/docs\/html\/service-bus\/message_bus.html#2-3-6-2-1","title":"FinderInvokeStrategy","content":"Instead of having this:$finder-&gt;findQueryOne(QueryOne $query, Deferred $deferred = null): void; you simply have this:$finder-&gt;find(QueryOne $query, Deferred $deferred = null): void; If you want to go back to the old behaviour, you can do the following things:a)class MyFinder { public function find(Query $query, Deferred $deferred = null): void { if ($query instanceof QueryOne) { $this-&gt;findQueryOne($query, $deferred); } elseif ($query instanceof QueryTwo) { $this-&gt;findQueryTwo($query, $deferred); } else { throw new \\InvalidArgumentException('Unknown query passed'); } } } or b) Write a custom FinderInvokeStrategy."},{"id":"\/docs\/html\/service-bus\/message_bus.html#2-3-6-2-2","title":"HandleCommandStrategy","content":"Same as for FinderInvokeStrategy, the handler is only expected have a handle(Command $command): void method. If you need the old behaviour back, implement this in your handlers or write a custom plugin."},{"id":"\/docs\/html\/service-bus\/message_bus.html#2-3-6-2-3","title":"OnEventStrategy","content":"Same as above: There handler is only expected to have a onEvent(Event $message): void method."},{"id":"\/docs\/html\/service-bus\/plugins.html#2-4","title":"PSB Plugins","content":"Plugins expand a message bus with additional functionality. PSB ships with a list of useful plugins that can be mixed and matched with your own implementations:"},{"id":"\/docs\/html\/service-bus\/plugins.html#2-4-1-1","title":"Prooph\\ServiceBus\\Plugin\\Router\\CommandRouter","content":"Use the CommandRouter to provide a list of commands (identified by their names) and their responsible command handlers.\/\/You can provide the list as an associative array in the constructor ... $router = new CommandRouter(array('My.Command.BuyArticle' =&gt; new BuyArticleHandler())); \/\/... or using the programmatic api $router-&gt;route('My.Command.RegisterUser')-&gt;to(new RegisterUserHandler()); \/\/Command handlers can be objects like shown above or everything that is callable (callbacks, callable arrays, etc.) ... $router-&gt;route('My.Command.SendPaymentEmail')-&gt;to(array($mailer, \"handleSendPaymentEmail\")); \/\/... or a string that can be used by a DIC to locate the command handler instance $router-&gt;route('My.Command.PayOrder')-&gt;to(\"payment_processor\"); \/\/Add the router to a CommandBus $router-&gt;attachToMessageBus($commandBus); "},{"id":"\/docs\/html\/service-bus\/plugins.html#2-4-1-2","title":"Prooph\\ServiceBus\\Plugin\\Router\\QueryRouter","content":"Use the QueryRouter to provide a list of queries (identified by their names) and their responsible finders.The QueryRouter share the same base class with the CommandRouter so its interface looks exactly the same."},{"id":"\/docs\/html\/service-bus\/plugins.html#2-4-1-3","title":"Prooph\\ServiceBus\\Plugin\\Router\\EventRouter","content":"Use the EventRouter to provide a list of event messages (identified by their names) and all interested listeners per event message.\/\/You can provide the list as an associative array in the constructor ... $router = new EventRouter(array('My.Event.ArticleWasBought' =&gt; array(new OrderCartUpdater(), new InventoryUpdater()))); \/\/... or using the programmatic api $router-&gt;route('My.Event.ArticleWasBought')-&gt;to(new OrderCartUpdater())-&gt;andTo(new InventoryUpdater()); \/\/Like command handlers, event message listeners can also be objects, callables or strings $router-&gt;route('My.Event.OrderWasPayed')-&gt;to(\"delivery_processor\"); \/\/Add the router to an EventBus $router-&gt;attachToMessageBus($eventBus); "},{"id":"\/docs\/html\/service-bus\/plugins.html#2-4-1-4","title":"Prooph\\ServiceBus\\Plugin\\Router\\RegexRouter","content":"The RegexRouter works with regular expressions to determine handlers for messages. It can be used together with a CommandBus, a QueryBus and an EventBus but for the latter it behaves a bit different. When routing a command or query the RegexRouter makes sure that only one pattern matches. If more than one pattern matches it throws a Prooph\\ServiceBus\\Exception\\RuntimeException. On the other hand when routing an event each time a pattern matches the corresponding listener is added to the list of listeners.\/\/You can provide the pattern list as an associative array in the constructor ... $router = new RegexRouter(array('\/^My\\.Command\\.Buy.*\/' =&gt; new BuyArticleHandler())); \/\/... or using the programmatic api $router-&gt;route('\/^My\\.Command\\.Register.*\/')-&gt;to(new RegisterUserHandler()); \/\/Add the router to a CommandBus $router-&gt;attachToMessageBus($commandBus); \/\/When routing an event you can provide a list of listeners for each pattern ... $router = new RegexRouter(array('\/^My\\.Event\\.Article.*\/' =&gt; array(new OrderCartUpdater(), new InventoryUpdater()))); \/\/... or using the programmatic api $router-&gt;route('\/^My\\.Event\\.Article.*\/')-&gt;to(new OrderCartUpdater()); \/\/The RegexRouter does not provide a andTo method like the EventRouter. \/\/You need to call route again for the same pattern, \/\/otherwise the router throws an exception $router-&gt;route('\/^My\\.Event\\.Article.*\/')-&gt;to(new InventoryUpdater()); \/\/Add the router to an EventBus $router-&gt;attachToMessageBus($eventBus); "},{"id":"\/docs\/html\/service-bus\/plugins.html#2-4-1-5","title":"Prooph\\ServiceBus\\Plugin\\Router\\AsyncSwitchMessageRouter","content":"The AsyncSwitchMessageRouter Router allows you to easily set up a single router to handle both your async and sync messages.To send messages via the Async Producer mark them with the Prooph\\ServiceBus\\Async\\AsyncMessage interface.The AsyncSwitchMessageRouter is a decorator that wraps your router. The first time the AsyncSwitchMessageRouter sees an async message it is sent via the Async Producer, after that the message is routed normally.\/\/You can define your primary router... $myRouter = new MyRouter(); \/\/ Create async message producer... $asyncMessageProducer = new AsyncMessageProducer(); \/\/ create your AsyncSwitchMessageRouter decorating your router... $router = new AsyncSwitchMessageRouter( $myRouter, $asyncMessageProducer ); \/\/Add the router to a CommandBus $router-&gt;attachToMessageBus($commandBus); "},{"id":"\/docs\/html\/service-bus\/plugins.html#2-4-2","title":"Invoke Strategies","content":"An invoke strategy knows how a message handler can be invoked. You can register many invoke strategies at once depending on how many different handler types you are using. The best way is to choose a convention and go with it. PSB ships with the invoke strategies listed below."},{"id":"\/docs\/html\/service-bus\/plugins.html#2-4-2-1","title":"Available Strategies","content":" HandleCommandStrategy: Prefixes the short class name of a command with handle. A command handler should have a public method named this way: AddProductHandler::handleAddProductToCart. If you prefer to have one command handler per command (recommended) then you don't need to attach the strategy but instead implement CommandHandler::__invoke. If you don't like __invoke you can also work with CommandHandler::handle. The HandleCommandStrategy checks if the handler has a single handle method if it cannot find an appropriate prefixed method name. OnEventStrategy: Prefixes the short class name of an event with on. A listener should have a public method named this way: OrderCartUpdater::onArticleWasBought. FinderInvokeStrategy: This strategy is responsible for invoking finders. It looks for a finder method named like the short class name of the query. Note: When a message bus detects that the message handler is callable invoke strategies are skipped and the message handler is directly invoked by the message bus."},{"id":"\/docs\/html\/service-bus\/plugins.html#2-4-3","title":"Guards","content":"The service bus ships with a Prooph\\ServiceBus\\Plugin\\Guard\\RouteGuard and a Prooph\\ServiceBus\\Plugin\\Guard\\FinalizeGuard. You can use them to protect the command bus and the query bus. For the command bus the route guard is sufficient. If the Prooph\\ServiceBus\\Plugin\\Guard\\AuthorizationService does not allow access to the command, an Prooph\\ServiceBus\\Plugin\\Guard\\UnauthorizedException is thrown. The route guard passes the message to the Prooph\\ServiceBus\\Plugin\\Guard\\AuthorizationService as context, so you can make assertions on it.If you want to protect the query bus, you can also use the route guard, but in some situations, you want to deny access based on the result of the query. In this case it's important to make checks on the query results. The finalize guard hands over a query result as context to the AuthorizationService.We also provide service-bus-zfc-rbac-bridge, a bridge to marry these guards with ZFC-Rbac. You can also find some configuration examples in this repository.Note: If you use both, the route guard and the finalize guard on the query bus and you want to make assertions on the query result, you need to make sure that the AuthorizationService can distinguish between the contexts (route guard passes query, finalize guard passes result)If you want to use the RouteGuard or FinalizeGuard with exposed message name in the exception message, configure your container accordingly, see: config\/services.php:21."},{"id":"\/docs\/html\/service-bus\/plugins.html#2-4-4","title":"ServiceLocatorPlugin","content":"This plugin uses a Interop\\Container\\ContainerInterface implementation to lazy-load message handlers. The following example uses a ZF2 ServiceManager as a service locator and illustrates how it can be used together with a command bus:use Zend\\ServiceManager\\ServiceManager; \/\/We tell the ServiceManager that it should provide an instance of My\\Command\\DoSomethingHandler \/\/when we request it with the alias My.Command.DoSomethingHandler $serviceManager = new ServiceManager(new Config([ 'invokables' =&gt; [ 'My.Command.DoSomethingHandler' =&gt; 'My\\Command\\DoSomethingHandler' ] ])); \/\/The ZF2\\ServiceManager implements Interop\\Container\\ContainerInterface since v2.6 (new ServiceLocatorPlugin($serviceManager))-&gt;attachToMessageBus($commandBus); $router = new CommandRouter(); \/\/In the routing map we use the alias of the command handler $router-&gt;route('My.Command.DoSomething')-&gt;to('My.Command.DoSomethingHandler'); $router-&gt;attachToMessageBus($commandBus); With this technique you can configure the routing for all your messages without the need to create all message handlers on every request. Only the responsible message handlers are lazy loaded by the service locator plugin."},{"id":"\/docs\/html\/service-bus\/plugins.html#2-4-5","title":"MessageProducerPlugin","content":"If you want to route all messages to a Prooph\\ServiceBus\\Async\\MessageProducer you can attach this plugin to a message bus. If it is attached to a command or query bus all messages will only be routed to the message producer. If it is attached to an event bus the message producer will be added to the list of event listeners.\/\/Let's say the zeromq message producer is available as a service in a container \/** @var \\Prooph\\ServiceBus\\Async\\MessageProducer $zeromqProducer *\/ $zeromqProducer = $container-&gt;get('async_event_producer'); \/\/We now only need to set up a message producer plugin and let the message bus use it. $messageProducerPlugin = new \\Prooph\\ServiceBus\\Plugin\\MessageProducerPlugin($zeromqProducer); $eventBus = new \\Prooph\\ServiceBus\\EventBus(); $messageProducerPlugin-&gt;attachToMessageBus($eventBus); \/\/Each event will now be routed to the async message producer $eventBus-&gt;dispatch($domainEvent); "},{"id":"\/docs\/html\/service-bus\/async_message_producer.html#2-5","title":"Async Message Producer","content":"Messaging becomes really interesting if you process your messages asynchronously. PSB can hide such an asynchronous workflow behind a unified interface. You can start with synchronous message dispatching by routing your messages directly to message handlers and if you later want to improve response times you can switch to async processing on a per message basis by routing the appropriate messages to a message producer which hands them over to a messaging system like RabbitMQ, ZeroMQ, Gearman, Beanstalkd or any other queue."},{"id":"\/docs\/html\/service-bus\/async_message_producer.html#2-5-1","title":"Available MessageProducer","content":" BernardProducer: Queue multi-backend providing different drivers like Doctrine DBAL and Predis (see https:\/\/github.com\/bernardphp\/bernard for a complete list of drivers) GuzzleHttpProducer: Send messages to a remote system using HTTP ZeroMQProducer: Async message handling using super fast and simple to set up ZeroMQ HumusAmqpProducer: Async handling using amqp protocol (f.e. with RabbitMQ). This also includes JSON-RPC features. "},{"id":"\/docs\/html\/service-bus\/async_message_producer.html#2-5-2","title":"Usage","content":"If you want to set up a bus that handles all messages async you can do so by attaching a Prooph\\ServiceBus\\Plugin\\MessageProducerPlugin initialized with your message producer of choice to a message bus.Let's look at a simple example using the psb-zeromq-producer\/\/app bootstrap $container = new Container; $container['config'] = [ 'prooph' =&gt; [ 'zeromq_producer' =&gt; [ 'dsn' =&gt; 'tcp:\/\/127.0.0.1:5555', \/\/ ZMQ Server Address. 'persistent_id' =&gt; 'example', \/\/ ZMQ Persistent ID to keep connections alive between requests. 'rpc' =&gt; false, \/\/ Use as Query Bus. ] ] ]; $factory = \\Prooph\\ServiceBus\\Message\\ZeroMQ\\Container\\ZeroMQMessageProducerFactory; $zmqProducer = $factory($container); $commandBus = new \\Prooph\\ServiceBus\\CommandBus(); $messageProducerForwarder = new \\Prooph\\ServiceBus\\Plugin\\MessageProducerPlugin($zmqProducer); $messageProducerForwarder-&gt;attachToMessageBus($commandBus); $echoText = new ExampleCommand('It works'); $commandBus-&gt;dispatch($echoText); You can also route individual messages to message producer by using a message router plugin.Note: Prooph\\ServiceBus\\Plugin\\Router\\RegexRouter is a good choice if you want to handle all messages of a specific namespace async."},{"id":"\/docs\/html\/service-bus\/async_message_producer.html#2-5-3","title":"Async Querying","content":"An async message producer for the QueryBus needs to provide a response by resolving the handed over React\\Promise\\Deferred. When using a messaging system like ZeroMQ for example you can make use of request\/response mode or RPC mode. HTTP APIs provide responses naturally. So these are both good candidates to use for remote querying."},{"id":"\/docs\/html\/service-bus\/factories.html#2-6","title":"Interop + Factories","content":"Instead of providing a module, a bundle, a bridge or similar framework integration prooph\/service-bus ships with interop factories."},{"id":"\/docs\/html\/service-bus\/factories.html#2-6-1","title":"Factory-Driven Message Bus Creation","content":"The concept behind these factories is simple but powerful. It allows us to provide you with bootstrapping logic for the message buses without the need to rely on a specific framework. However, the factories have three requirements."},{"id":"\/docs\/html\/service-bus\/factories.html#2-6-1-1","title":"Requirements","content":" Your Inversion of Control container must implement the interop-container interface. interop-config must be installed The application configuration should be registered with the service id config in the container. Note: Don't worry, if your environment doesn't provide the requirements. You can always bootstrap a message bus by hand. Just look at the factories for inspiration in this case."},{"id":"\/docs\/html\/service-bus\/factories.html#2-6-2","title":"Customizing via Configuration","content":"In the config folder of prooph\/service-bus you will find example configuration files. Configuration is a simple PHP array flavored with some comments to help you understand the structure.Now follow the simple steps below to integrate prooph\/service-bus in your framework and\/or application. Merge configuration into your application config either by hand or by using the mechanism of your framework. Customize the configuration so that it meet your needs. The comments in the config file will tell you more. (Only required if not done by your framework) Make your application config available as a service in the Inversion of Control container. Use config as the service id (common id for application config). Register the message buses as services in your IoC container and use the located in src\/Container to create the different message buses. How you can register a message bus depends on your container. Some containers like zend-servicemanager or pimple-interop allow you to map a service id to an invokable factory. If you use such an IoC container you are lucky. In this case you can use the prooph\/service-bus factories as-is. We recommend using Prooph\\ServiceBus\\&lt;CommandBus\/EventBus\/QueryBus::class as service id. *Note: If you're still unsure how to do it you might have a look at the BusFactoriesTest located in the tests folder."},{"id":"\/docs\/html\/event-store\/intro.html#3-1","title":"ProophEventStore","content":"PHP 7.1 EventStore Implementation. "},{"id":"\/docs\/html\/event-store\/intro.html#3-1-1","title":"Overview","content":"Prooph Event Store is capable of persisting event messages that are organized in streams. Prooph\\EventStore\\EventStore itself is a facade for different persistence adapters (see the list below) and adds event-driven hook points for Prooph\\EventStore\\Plugin\\Plugins which make the Event Store highly customizable."},{"id":"\/docs\/html\/event-store\/intro.html#3-1-2","title":"Installation","content":"You can install prooph\/event-store via composer by adding \"prooph\/event-store\": \"^7.0\" as requirement to your composer.json."},{"id":"\/docs\/html\/event-store\/intro.html#3-1-3","title":"Available Persistence Adapters","content":" Mongo DB - stable Doctrine DBAL - stable "},{"id":"\/docs\/html\/event-store\/intro.html#3-1-4","title":"Available Snapshot Adapters","content":" Mongo DB - stable Doctrine DBAL - stable Memcached - stable "},{"id":"\/docs\/html\/event-store\/intro.html#3-1-5","title":"Quick Start","content":"For a short overview please see the annotated Quickstart in the examples folder."},{"id":"\/docs\/html\/event-store\/intro.html#3-1-6","title":"Documentation","content":"Documentation is in the doc tree, and can be compiled using bookdown.$ php .\/vendor\/bin\/bookdown docs\/bookdown.json $ php -S 0.0.0.0:8080 -t docs\/html\/ Then browse to http:\/\/localhost:8080\/"},{"id":"\/docs\/html\/event-store\/intro.html#3-1-7","title":"Support","content":" Ask questions on prooph-users mailing list. File issues at https:\/\/github.com\/prooph\/event-store\/issues. Say hello in the prooph gitter chat. "},{"id":"\/docs\/html\/event-store\/intro.html#3-1-8","title":"Contribute","content":"Please feel free to fork and extend existing or add new plugins and send a pull request with your changes! To establish a consistent code quality, please provide unit tests for all your changes and may adapt the documentation."},{"id":"\/docs\/html\/event-store\/intro.html#3-1-9","title":"License","content":"Released under the New BSD License."},{"id":"\/docs\/html\/event-store\/event_store.html#3-2","title":"Prooph Event Store","content":"Prooph Event Store is the central component of this package. If you are familiar with doctrine you can compare it with doctrine's EntityManager. However, Prooph Event Store is especially designed to add a centralized, event-driven system on top of different low level event stream persistence adapters (f.e. MySQL or Postgres). The event-driven store is the unique selling point of prooph\/event-store compared to other libraries. So let's directly jump into it and see what you can do with it."},{"id":"\/docs\/html\/event-store\/event_store.html#3-2-1","title":"Event Hooks","content":"Requirements: an event store wrapped with Prooph\\EventStore\\ActionEventEmitterEventStore.Action events are triggered when methods of the event store are invoked. The action events are named like the event store methods. The following events are available (event target is always the event store): create: event params: stream - result params: streamExistsAlready appendTo: event params: streamName, streamEvents - result params: streamNotFound, concurrencyException load: event params: streamName, fromNumber, count, metadatamatcher - result params: streamEvents, streamNotFound loadReverse: event params: streamName, fromNumber, count, metadatamatcher - result params: streamEvents, streamNotFound delete: event params: streamName - result params: streamNotFound hasStream: event params: streamName - result params: result fetchStreamMetadata: event params: streamName - result params: metadata, streamNotFound updateStreamMetadata: event params: streamName, metadata - result params: streamNotFound fetchStreamNames: event params: filter, metadataMatcher, limit, offset - result params: streamNames fetchStreamNamesRegex: event params: filter, metadataMatcher, limit, offset - result params: streamNames fetchCategoryNames: event params: filter, offset, limit - result params: categoryNames fetchCategoryNamesRegex: event params: filter, offset, limit - result params: categoryNames If the event store implements additionally \\Prooph\\EventStore\\CanControlTransactionActionEventEmitterAwareEventStore, the following additional events are available: beginTransaction: event params: none - result params: transactionAlreadyStarted commit: event params: none - result params: transactionNotStarted rollback: event params: none - result params: `transactionNotStarted "},{"id":"\/docs\/html\/event-store\/event_store.html#3-2-2","title":"Attaching Plugins","content":"If you had a look at the quick start you should already be familiar with one possibility to attach an event listener plugin.$eventStore-&gt;attach( 'commit', function (\\Prooph\\Common\\Event\\ActionEvent $actionEvent) { \/\/plugin logic here }, 1000 \/\/ priority ); More complex plugins are typically provided as classes with own dependencies. A plugin can implement the Prooph\\EventStore\\Plugin\\Plugin interface and can then attach itself to the event store in the Plugin::attachToEventStore($eventStore) method. Implementing the interface is especially useful when you use the event store factory."},{"id":"\/docs\/html\/event-store\/event_store.html#3-2-3","title":"Plugin Use Cases","content":"The event-driven system opens the door for customizations. Here are some ideas what you can do with it: Attach a domain event dispatcher on the create and appendTo event Filter events before they are stored Add event metadata like a causation id (id of the command which caused the event) Convert events into custom event objects before they are passed back to a repository Implement your own Unit of Work and synchronizes it with the transaction, commit and rollback events ... "},{"id":"\/docs\/html\/event-store\/event_store.html#3-2-4","title":"Metadata enricher","content":"By default the component is shipped with a plugin to automatically add metadata for each events. For instance you may want to add information about the command which caused the event or even the user who triggered that command.Here is an example of usage:&lt;?php use Prooph\\Common\\Messaging\\Message; use Prooph\\EventStore\\Metadata\\MetadataEnricher; use Prooph\\EventStore\\Metadata\\MetadataEnricherAggregate; use Prooph\\EventStore\\Metadata\\MetadataEnricherPlugin; class IssuerMetadataEnricher implements MetadataEnricher { \/\/ ... public function enrich(Message $event): Message { if ($this-&gt;currentUser) { $event = $event -&gt;withAddedMetadata('issuer_type', 'user') -&gt;withAddedMetadata('issuer_id', $this-&gt;currentUser-&gt;id()); } return $event; } } $plugin = new MetadataEnricherPlugin(new MetadataEnricherAggregate([ $issuerMetadataEnricher, $causationMetadataEnricher, $otherMetadataEnricher, ])); $plugin-&gt;attachToEventStore($eventStore); "},{"id":"\/docs\/html\/event-store\/event_store.html#3-2-5","title":"Internal metadata","content":"All internal metadata is prefixed with _ (underscore), f.e. _causation_id. Do not use metadata keys starting with an underscore, as this is reserved for prooph internals."},{"id":"\/docs\/html\/event-store\/projections.html#3-3","title":"Projections","content":"New in v7 are queries and projectons."},{"id":"\/docs\/html\/event-store\/projections.html#3-3-1","title":"Queries","content":"We are talking here about event store queries, not queries on your read model. An event store query reads one or multiple event stream, aggregates some state from it and makes it accessible. A query is non-persistent, will only get executed once, return a result, and that's it.To get started, let's take a simple example where we want to query the event-store, how often a given user has changed his username.$query = $projectionManager-&gt;createQuery(); $query -&gt;init(function (): array { return ['count' =&gt; 0]; }) -&gt;fromStream('user-123') -&gt;when([ 'user-name-changed' =&gt; function ( array $state, UsernameChanged $event ): array { $state['count']++; return $state; } ]) -&gt;run(); echo 'user 123 changed his name ' . $query-&gt;getState()['count'] . ' times'; You can also reset and run the query again:$query-&gt;reset(); $query-&gt;run(); Or you can stop the projection at any point in time.$query = $projectionManager-&gt;createQuery(); $query -&gt;init(function (): array { return ['count' =&gt; 0]; }) -&gt;fromStream('user-123') -&gt;when([ 'user-name-changed' =&gt; function ( array $state, UsernameChanged $event ): array { $state['count']++; $this-&gt;stop(); \/\/ stop query now return $state; } ]) -&gt;run(); Queries can be used to answer a given question easily, because you don't need to figure out in which read model the data is present (maybe it's not?) and how to query it there (maybe a lot of joins are needed in RDBMS). Also you can do temporal queries very easy, which is hard until impossible to do with any other database system."},{"id":"\/docs\/html\/event-store\/projections.html#3-3-2","title":"Projections","content":"Projections are like queries, but first of all, they are persistent, the created state is persistent and can be queried later, and also the projection is running forever (in most cases).Compared to queries, the projectors have a couple of additional methods:public function getName(): string; public function emit(Message $event): void; public function linkTo(string $streamName, Message $event): void; public function delete(bool $deleteEmittedEvents): void;  getName() - obviously returns the given name of that projection emit(Message $event) - emits a new event that will be persisted on a stream with the same name as the projection linkTo(string $streamName, Message $event) - emits a new event, that will be persisted on a specific stream delete(bool $deleteEmittedEvents) - deletes the projection completely, the $deleteEmittedEvents flag tells, whether or not to delete emitted events. An example:$projector = $projectionManager-&gt;createProjection('test_projection'); $projector -&gt;fromStream('user-123') -&gt;whenAny( function (array $state, Message $event): array { $this-&gt;linkTo('foo', $event); \/\/ create a copy of the event to a new stream return $state; } ) -&gt;run(); $projector = $projectionManager-&gt;createProjection('test_projection'); $projector -&gt;init(function (): array { return ['count' =&gt; 0]; }) -&gt;fromCategory('user') -&gt;when([ 'user-registered' =&gt; function (array $state, Message $event): array { $state['count']++; return $state; } ) -&gt;run(); This would count all registered users."},{"id":"\/docs\/html\/event-store\/projections.html#3-3-2-1","title":"Options","content":"There are three options common to all projectors:OPTION_CACHE_SIZE = 'cache_size';The cache size is how many stream names are cached in memory, the higher the number to less queries are executed and therefor makes the projections run faster, but it consumes more memory.OPTION_SLEEP = 'sleep';The sleep options tells the projection to sleep that many microseconds, before querying the event store again, when no events were found in the last trip. This reduces having lots of cpu cycles without the projection doing anything really.OPTION_PERSIST_BLOCK_SIZE = 'persist_block_size';The persist block size tells the projector, to persist its changes after a given amount of operations. This increases the speed of the projection a lot. When you persist only every 1000 events compared to persist on every event, then 999 write operations are saved. The higher the number, the less write operations are made to your system, making the projections run faster. On the other side, in case of an error, you need to redo the last operations again. If you are publishing events to the outside world within a projection, you may think of a persist block size of 1 only.OPTION_LOCK_TIMEOUT_MS = 'lock_timeout_ms'Indicates the time (in microseconds) the projector is locked. During this time no other projector with the same name can be started. A running projector will update the lock timeout on every loop."},{"id":"\/docs\/html\/event-store\/projections.html#3-3-3","title":"Read Model Projections","content":"Projections can also be used to create read models. A read model has to implement Prooph\\EventStore\\Projection\\ReadModel. Prooph also ships with an Prooph\\EventStore\\Projection\\AbstractReadModel that helps you to implement a read model yourself.One nice thing about read model projections is, that you don't need a migration script for your read models at all. When you need to make a change to your read model, you simply alter your read model implementation, stop your current running projections, reset it and run it again."},{"id":"\/docs\/html\/event-store\/projections.html#3-3-3-1","title":"Options","content":"The read model projectors have the same options as the normal projectors, see above for more explanations."},{"id":"\/docs\/html\/event-store\/projections.html#3-3-3-2","title":"Example","content":"$projector = $projectionManager-&gt;createReadModelProjection( 'test_projection', $readModel ); $projector -&gt;fromAll() -&gt;when([ 'user-created' =&gt; function ($state, Message $event) { $this-&gt;readModelProjection()-&gt;insert( 'name', $event-&gt;payload()['name'] ); }, 'username-changed' =&gt; function ($state, Message $event) { $this-&gt;readModelProjection()-&gt;update( 'name', $event-&gt;payload()['name'] ); } ]) -&gt;run(); "},{"id":"\/docs\/html\/event-store\/projections.html#3-3-4","title":"Projection Manager","content":"The projection manager can do the following for you: Create queries &amp; projectors Delete \/ reset \/ stop projections Fetch projection names Fetch projection status Fetch projection stream position Fetch projection state While the most is pretty straightforward, the delete \/ reset \/ stop projection methods may need some additional explanation:When you call stopProjection($name) (or delete or reset) a message is send to the projection. This will notify the running projection, that it should act accordingly. This means, that once you call stopProjection the projection might not be stopped immediately, but it could take a few seconds until the projection is finally stopped."},{"id":"\/docs\/html\/event-store\/projections.html#3-3-5","title":"Internal projection mames","content":"All internal projetion names are prefixed with $ (dollar-sign), f.e. $ct-. Do not use projection names starting with a dollar-sign, as this is reserved for prooph internals."},{"id":"\/docs\/html\/event-store\/upcasting.html#3-4","title":"Upcasting","content":"Imagine v1 of your application already runs in production. You've worked on great new features the last weeks and want to deploy v1.1 but structure of some domain events did change. The new versions of your aggregates would not be able to replay v1 domain events correctly. To solve the issue you can upcast your history events."},{"id":"\/docs\/html\/event-store\/upcasting.html#3-4-1","title":"How does it work?","content":"Basically you need to write a migration script (much like a normal DB migration script). The script should load all effected events from the event store and manipulate them to be compliant with version 1.1 of your aggregates. Then simply replace the original events in the stream with the changed ones.Note: The event store only offers methods to load events from a stream and add new ones, but it has no method to replace them. The reason for that is simple: \"Upcasting\" is nothing your normal program should not have access to. It is really only a way to upgrade your application to the next version. So your upcasting script needs to make use of low-level functionality provided by the underlying driver for the event store adapter."},{"id":"\/docs\/html\/event-store\/upcasting.html#3-4-2","title":"But how to avoid conflicts during the upcasting process?","content":"Well, that depends on your infrastructure and deployment strategy. The easiest way is to take your application offline, perform the upcasting script, deploy new version of the application and bring the system online again.A more complex option with no or very little downtime is to use a special MessageFactory. Make the MessageFactory aware of the differences between v1 and v1.1 of your events. Deploy the modified factory together with version 1.1 of your application. The factory takes care of translating old events into new ones. Perform the \"upcasting\" script in the background and once it has replaced all old events you can remove the translation logic from the factory again and exchange it with the simple factory you used before.Note: Each event store adapter allows you to set it up with a custom message factory. Please refer to the adapter documentation of your choice to get more information."},{"id":"\/docs\/html\/event-store\/upcasting.html#3-4-3","title":"Upasting on the fly","content":"Starting in v7 prooph offers an upcasting plugin for the event store. Setup is very easy:$upcaster = new MyUpcaster(); $plugin = new UpcastingPlugin($upcaster); $plugin-&gt;attachToEventStore($eventStore); So next time you load your events, they will get upcasted automatically (but not persisted back to the database).The upcaster interface is very easy:interface Upcaster { \/** * @param Message $message * @return array of messages *\/ public function upcast(Message $message): array; } Prooph also ships with a SingleEventUpcaster, an abstract class to help you create upcaster easily. Additionally an UpcasterChain is provided, so you can combine upcaster easily:$upcaster1 = new MyUpcaster1(); $upcaster2 = new MyUpcaster2(); $upcaster3 = new MyUpcaster3(); $chain = new UpcasterChain($upcaster1, $upcaster2, $upcaster3); $plugin = new UpcastingPlugin($chain); $plugin-&gt;attachToEventStore($eventStore); "},{"id":"\/docs\/html\/event-store\/interop_factories.html#3-5","title":"Interop Factories","content":"Instead of providing a module, a bundle, a bridge or similar framework integration prooph\/event-store ships with interop factories."},{"id":"\/docs\/html\/event-store\/interop_factories.html#3-5-1","title":"Factory-Driven Creation","content":"The concept behind these factories (see src\/Container folder) is simple but powerful. It allows us to provide you with bootstrapping logic for the event store and related components without the need to rely on a specific framework. However, the factories have three requirements."},{"id":"\/docs\/html\/event-store\/interop_factories.html#3-5-1-1","title":"Requirements","content":" Your Inversion of Control container must implement the PSR Container interface. interop-config must be installed The application configuration should be registered with the service id config in the container. Note: Don't worry, if your environment doesn't provide these requirements, you can always bootstrap the components by hand. Just look at the factories for inspiration in this case."},{"id":"\/docs\/html\/event-store\/interop_factories.html#3-5-1-2","title":"InMemoryEventStoreFactory","content":"If the requirements are met you just need to add a new section in your application config ...[ 'prooph' =&gt; [ 'event_store' =&gt; [ 'default' =&gt; [ 'wrap_action_event_emitter' =&gt; true, 'metadata_enrichers' =&gt; [ \/\/ The factory will get the metadata enrichers and inject them in the MetadataEnricherPlugin. \/\/ Note: you can obtain the same result by instanciating the plugin yourself \/\/ and pass it to the 'plugin' section bellow. 'metadata_enricher_1', 'metadata_enricher_2', \/\/ ... ], 'plugins' =&gt; [ \/\/And again the factory will use each service id to get the plugin from the container \/\/Plugin::attachToEventStore($eventStore) is then invoked by the factory so your plugins \/\/ get attached automatically \/\/Awesome, isn't it? 'plugin_1_service_id', 'plugin_2_service_id', \/\/... ], ], ], ], 'dependencies' =&gt; [ 'factories' =&gt; [ 'inmemoryeventstore' =&gt; [ \\Prooph\\EventStore\\Container\\InMemoryEventStoreFactory::class, 'default', ], ], ], \/\/... other application config here ] $eventStore = $container-&gt;get('inmemoryeventstore');"},{"id":"\/docs\/html\/event-store\/interop_factories.html#3-5-1-3","title":"InMemoryProjectionManagerFactory","content":"[ 'prooph' =&gt; [ 'projection_manager' =&gt; [ 'default' =&gt; [ 'event_store' =&gt; 'inmemoryeventstore', ], ], ], 'dependencies' =&gt; [ 'factories' =&gt; [ 'inmemoryeventstoreprojectionmanager' =&gt; [ \\Prooph\\EventStore\\Container\\InMemoryProjectionManagerFactory::class, 'default', ], ], ], \/\/... other application config here ] $projectionManager = $container-&gt;get('inmemoryeventstoreprojectionmanager');"},{"id":"\/docs\/html\/event-store\/migration.html#3-6-1","title":"Moved classes","content":"The Prooph\\Snapshot\\* classes are now moved to its own repository SnapshotStore.The Prooph\\Aggregate\\* classes are now moved into the event-sourcing repository."},{"id":"\/docs\/html\/event-store\/migration.html#3-6-2","title":"Interfaces VS adapters","content":"The event store now ships with a Prooph\\EventStore\\ReadOnlyEventStore and a Prooph\\EventStore\\EventStore interface. No event store adapters exist any more, instead there are different implementations of an event store."},{"id":"\/docs\/html\/event-store\/migration.html#3-6-3","title":"ActionEventEmitterEventStore","content":"In order to use action events like in v6, you need to wrap your event store.$eventStore = new ActionEventEmitterEventStore($eventStore); or$eventStore = new TransactionalActionEventEmitterEventStore($eventStore); Also there are no more .pre and .post commit hooks any more, instead this is handled with different priorities now."},{"id":"\/docs\/html\/event-store\/migration.html#3-6-4","title":"Plugins","content":"Instead of calling$plugin-&gt;setUp($eventStore); you now need to call$plugin-&gt;attachToEventStore($eventStore); "},{"id":"\/docs\/html\/event-store\/migration.html#3-6-5","title":"Interaction with the event store","content":"If you are using the event-store together with the event-sourcing component, most stuff is pretty much unchanged for you, as you don't interact with the event store directly (this is done by the event-sourcing component).If you are making calls to the event store yourself, take a look at the event_store docs on how the new usage is."},{"id":"\/docs\/html\/event-store\/migration.html#3-6-6","title":"DB migrations","content":"If you are using v6 with MySQL (using doctrine adpater) and you want to switch to v7 with MySQL (using pdo-event-store), you need to upgrade your database before you do this (same for other db vendors of course). The way events are persisted have changed and you cannot simply update your source code to make this change. You need to write a migration script, take the database offline, perform the migration and go back online.Things to do to migrate: Read all events Update event metadata Persist the event back to a new stream created with v7 This would need to be done for all event streams.As this is a very tough job, we don't provide any migration script currently and for some applications a downtime is not acceptable, then v7 might not be the right choice for you, use it when you can take the application offline for a while and you can perform the db migration or wait with v7 usage, until you start a new project.We will support v6 series with bugfixes at least for a year (until mid 2018)."},{"id":"\/docs\/html\/event-sourcing\/intro.html#4-1","title":"ProophEventSourcing","content":"Simple and lightweight event sourcing library with out of the box support for ProophEventStore #InstallationYou can install ProophEventSourcing via composer by adding \"prooph\/event-sourcing\": \"^5.0\" as requirement to your composer.json.#UsageOur quickstart should give you a starting point. It's a very small domain but shows you the useage of ProophEventSourcing and the integration with ProophEventStore.#ProophEventStore IntegrationProophEventSourcing ships with a ProophEventStore AggregateTranslator to connect the store with the bundled AggregateRoot."},{"id":"\/docs\/html\/event-sourcing\/intro.html#4-1","title":"Support","content":" Ask any questions on prooph-users google group. File issues at https:\/\/github.com\/prooph\/event-sourcing\/issues. #Used Third-Party Libraries Uuids of the AggregateChangedEvents are generated with ramsey\/uuid Assertions are performed by beberlei\/assert "},{"id":"\/docs\/html\/event-sourcing\/repositories.html#4-2","title":"Working with Repositories","content":"Repositories typically connect your domain model with the persistence layer (part of the infrastructure). Following DDD suggestions your domain model should be database agnostic. An event store is of course some kind of database so you are likely looking for a third-party event store that gets out of your way.The good news is: You've found one!But you need to get familiar with the concept. So you're pleased to read this document and follow the example. Afterwards you should be able to integrate prooph\/event-store into your infrastructure without coupling it with your model."},{"id":"\/docs\/html\/event-sourcing\/repositories.html#4-2-1","title":"Event Sourced Aggregates","content":"We assume that you want to work with event sourced aggregates. If you are not sure what we are talking about please refer to the great educational project Buttercup.Protects by Mathias Verraes. prooph\/event-store does not include base classes or traits to add event sourced capabilities to your aggregates.Sounds bad? It isn't!It is your job to write something like Buttercup.Protects for your model. Don't be lazy in this case.The event store doesn't know anything about aggregates. It is just interested in Prooph\\Common\\Messaging\\Message events. These events are organized in Prooph\\EventStore\\Streams. A repository is responsible for extracting pending events from aggregates and putting them in the correct stream. And the repository must also be able to load persisted events from a stream and reconstitute an aggregate. To provide this functionality the repository makes use of various helper classes explained below."},{"id":"\/docs\/html\/event-sourcing\/repositories.html#4-2-2","title":"AggregateType","content":"Each repository is responsible for one \\Prooph\\EventSourcing\\Aggregate\\AggregateType."},{"id":"\/docs\/html\/event-sourcing\/repositories.html#4-2-3","title":"AggregateTranslator","content":"To achieve 100% decoupling between layers and\/or contexts you can make use of translation adapters. For prooph\/event-store such a translation adapter is called a Prooph\\EventSourcing\\Aggregate\\AggregateTranslator.The interface requires you to implement 5 methods: extractAggregateId extractAggregateVersion extractPendingStreamEvents reconstituteAggregateFromHistory replayStreamEvents To make your life easier prooph\/event-sourcing ships with a \\Prooph\\EventSourcing\\EventStoreIntegration\\AggregateTranslator which implements the interface."},{"id":"\/docs\/html\/event-sourcing\/repositories.html#4-2-4","title":"Snapshot Store","content":"A repository can be set up with a snapshot store to speed up loading of aggregates.You need to install Prooph SnapshotStore and a persistable implementation of it, like pdo-snapshot-store or mongodb-snapshot-store."},{"id":"\/docs\/html\/event-sourcing\/repositories.html#4-2-5","title":"Event Streams","content":"An event stream can be compared with a table in a relational database (and in case of the pdo-event-store it is a table). By default the repository puts all events of all aggregates (no matter the type) in a single stream called event_stream. If you wish to use another name, you can pass a custom Prooph\\EventStore\\StreamName to the repository. This is especially useful when you want to have an event stream per aggregate type, for example store all user related events in a user_stream.The repository can also be configured to create a new stream for each new aggregate instance. You'll need to turn the last constructor parameter oneStreamPerAggregate to true to enable the mode. If the mode is enabled the repository builds a unique stream name for each aggregate by using the AggregateType and append the aggregateId of the aggregate. The stream name for a new Acme\\User with id 123 would look like this: Acme\\User-123.Depending on the event store implementation used the stream name is maybe modified by the implementation to replace or removed non supported characters. Check your event store implemtation of choice for details. You can also override AggregateRepository::determineStreamName to apply a custom logic for building the stream name."},{"id":"\/docs\/html\/event-sourcing\/repositories.html#4-2-6","title":"Wiring It Together","content":"Best way to see a repository in action is by looking at the \\ProophTest\\EventSourcing\\Aggregate\\AggregateRepositoryTest."},{"id":"\/docs\/html\/event-sourcing\/repositories.html#4-2-6-1","title":"Set Up","content":"$this-&gt;repository = new AggregateRepository( $this-&gt;eventStore, AggregateType::fromAggregateRootClass('ProophTest\\EventSourcing\\Mock\\User'), new AggregateTranslator() ); $this-&gt;eventStore-&gt;create(new Stream(new StreamName('event_stream'), new ArrayIterator())); Notice the injected dependencies! Snapshot store, stream name and stream mode are optional and not injected for all tests. Therefore stream name defaults to event_stream and the repository appends all events to this stream. For the test cases we also create the stream on every run. In a real application you need to do this only once.\/** * @test *\/ public function it_adds_a_new_aggregate(): void { $user = User::create('John Doe', 'contact@prooph.de'); $this-&gt;repository-&gt;saveAggregateRoot($user); $fetchedUser = $this-&gt;repository-&gt;getAggregateRoot( $user-&gt;getId()-&gt;toString() ); $this-&gt;assertInstanceOf('ProophTest\\EventStore\\Mock\\User', $fetchedUser); $this-&gt;assertNotSame($user, $fetchedUser); $this-&gt;assertEquals('John Doe', $fetchedUser-&gt;name()); $this-&gt;assertEquals('contact@prooph.de', $fetchedUser-&gt;email()); } In the first test case you can see how an aggregate (the user entity in this case) can be added to the repository.\/** * @test *\/ public function it_tracks_changes_of_aggregate(): void { $user = User::create('John Doe', 'contact@prooph.de'); $this-&gt;repository-&gt;saveAggregateRoot($user); $fetchedUser = $this-&gt;repository-&gt;getAggregateRoot( $user-&gt;getId()-&gt;toString() ); $this-&gt;assertNotSame($user, $fetchedUser); $fetchedUser-&gt;changeName('Max Mustermann'); $this-&gt;repository-&gt;saveAggregateRoot($fetchedUser); $fetchedUser2 = $this-&gt;repository-&gt;getAggregateRoot( $user-&gt;getId()-&gt;toString() ); $this-&gt;assertNotSame($fetchedUser, $fetchedUser2); $this-&gt;assertEquals('Max Mustermann', $fetchedUser2-&gt;name()); } Here we first add the user, then load it with the help of the repository and finally we change the user entity. The change causes a UserNameChanged event.Note the identity map is cleared after each transaction commit. You may notice the assertNotSame checks in the test. The repository keeps an aggregate only in memory as long as the transaction is active. Otherwise multiple long-running processes dealing with the same aggregate would run into concurrency issues very fast.The test case has some more tests including snapshot usage and working with different stream names \/ strategies. Just browse through the test methods for details."},{"id":"\/docs\/html\/event-sourcing\/repositories.html#4-2-7","title":"Loading of thousands aggregates","content":"If you need to load thousands of aggregates for reading only, your memory can be exhausted, because the AggregateRepository uses an identity map. So every loaded aggregate is stored there, unless a commit is executed. If you have a read only process, you should consider to clear the identity map at some time. This can be done by calling clearIdentityMap().$thousandsOfAggregateIds = [ \/\/ lots of ids here ]; $number = 0; foreach ($thousandsOfAggregateIds as $aggregateId) { $aggregate = $this-&gt;repository-&gt;getAggregateRoot($aggregateId); $number++; \/\/ do something with the aggregate data e.g. build read model \/\/ clear on every 500th aggregate if (0 === $number % 500) { $this-&gt;repository-&gt;clearIdentityMap(); } } "},{"id":"\/docs\/html\/event-sourcing\/snapshots.html#4-3","title":"Snapshots","content":"One of the counter-arguments against Event-Sourcing you might heard about is that replaying events takes too much time.Replaying 20 events for an aggregate is fast, 50 is ok, but 100 events and more become slow depending on the data of the events and the operations needed to replay them. A DDD rule of thumb says aggregates should be kept small. Keeping that in mind you should be fine with 50 events per aggregate in most cases."},{"id":"\/docs\/html\/event-sourcing\/snapshots.html#4-3-1","title":"But my aggregates record tons of events!","content":"If aggregate reconstitution gets slow you can add an additional layer to the system which is capable of providing aggregate snapshots.Choose one of the Prooph\\SnapshotStore\\* to take snapshots. Inject the snapshot store into an aggregate repository and the repository will use the snapshot store to speed up aggregate loading.Our example application proophessor-do contains a snapshotting tutorial.Note: All SnapshotStores ship with interop factories to ease set up.For more informations about snapshots and how to configure them, see Prooph Snapshotter."},{"id":"\/docs\/html\/event-sourcing\/inheritance.html#4-4","title":"Inheritance with Aggregate Roots","content":"If you want to make inheritance work with aggregate roots using a common repository for all subtypes, this can also be achieved very easily."},{"id":"\/docs\/html\/event-sourcing\/inheritance.html#4-4-1","title":"An example","content":"Consider the following use case:abstract class User extends \\Prooph\\EventSourcing\\AggregateRoot { protected $name; protected $email; public function name(): string { return $this-&gt;name; } public function email(): string { return $this-&gt;email; } protected function apply(AggregateChanged $e): void { if ($e instanceof UserWasRegisterd) { $this-&gt;name = $e-&gt;name(); $this-&gt;email = $e-&gt;email(); } } } class Admin extends User { public static function register(string $name, string $email): Admin { $self = new self(); $self-&gt;recordThat(UserWasRegisterd::withData('admin', $name, $email); return $self; } } class Member extends User { public static function register(string $name, string $email): Member { $self = new self(); $self-&gt;recordThat(UserWasRegisterd::withData('member', $name, $email); return $self; } } So in order to make this work, you need 3 small changes in your application."},{"id":"\/docs\/html\/event-sourcing\/inheritance.html#4-4-2","title":"Step 1: Create a UserAggregateTranslator","content":"final class UserAggregateTranslator extends \\Prooph\\EventSourcing\\EventStoreIntegration\\AggregateTranslator { \/** * @param \\Prooph\\EventStore\\Aggregate\\AggregateType $aggregateType * @param \\Iterator $historyEvents * @return object reconstructed AggregateRoot *\/ public function reconstituteAggregateFromHistory( \\Prooph\\EventStore\\Aggregate\\AggregateType $aggregateType, \\Iterator $historyEvents ) { $aggregateRootDecorator = $this-&gt;getAggregateRootDecorator(); $firstEvent = $historyEvents-&gt;current(); $type = $firstEvent-&gt;type(); if ($type === 'admin') { return $aggregateRootDecorator-&gt;fromHistory(Admin::class, $historyEvents); } elseif ($type === 'member') { return $aggregateRootDecorator-&gt;fromHistory(Member::class, $historyEvents); } } } "},{"id":"\/docs\/html\/event-sourcing\/inheritance.html#4-4-3","title":"Step 2: Change the assertion method in the EventStoreUserCollection","content":"final class EventStoreUserCollection extends \\Prooph\\EventStore\\Aggregate\\AggregateRepository { public function save(User $user): void { $this-&gt;saveAggregateRoot($user); } public function get(UserId $userId): ?User { return $this-&gt;getAggregateRoot($userId-&gt;toString()); } protected function assertAggregateType($eventSourcedAggregateRoot) { \\Assert\\Assertion::isInstanceOf($eventSourcedAggregateRoot, User::class); } } "},{"id":"\/docs\/html\/event-sourcing\/inheritance.html#4-4-4","title":"Step 3: Make use of your custom AggregateTranslator","content":"final class EventStoreUserCollectionFactory { public function __invoke(ContainerInterface $container): EventStoreUserCollection { return new EventStoreUserCollection( $container-&gt;get(EventStore::class), AggregateType::fromAggregateRootClass(User::class), new UserAggregateTranslator() ); } } If you use the provided container factory (\\Prooph\\EventStore\\Container\\Aggregate\\AbstractAggregateRepositoryFactory) then you can also just change the aggregate_translator key in your config to point to the new UserAggregateTranslator and register the UserAggregateTranslator in your container.see also: http:\/\/www.sasaprolic.com\/2016\/02\/inheritance-with-aggregate-roots-in.html"},{"id":"\/docs\/html\/event-sourcing\/interop_factories.html#4-5","title":"Interop Factories","content":"Instead of providing a module, a bundle, a bridge or similar framework integration prooph\/event-store ships with interop factories."},{"id":"\/docs\/html\/event-sourcing\/interop_factories.html#4-5-1","title":"Factory-Driven Creation","content":"The concept behind these factories (see src\/Container folder) is simple but powerful. It allows us to provide you with bootstrapping logic for the event store and related components without the need to rely on a specific framework. However, the factories have three requirements."},{"id":"\/docs\/html\/event-sourcing\/interop_factories.html#4-5-1-1","title":"Requirements","content":" Your Inversion of Control container must implement the PSR Container interface. interop-config must be installed The application configuration should be registered with the service id config in the container. Note: Don't worry, if your environment doesn't provide these requirements, you can always bootstrap the components by hand. Just look at the factories for inspiration in this case."},{"id":"\/docs\/html\/event-sourcing\/interop_factories.html#4-5-1-2","title":"AggregateRepositoryFactory","content":"To ease set up of repositories for your aggregate roots prooph\/event-store also ships with a Prooph\\EventStore\\Container\\Aggregate\\AbstractAggregateRepositoryFactory. It is an abstract class implementing the container-interop RequiresContainerId interface. The containerId method itself is not implemented in the abstract class. You have to extend it and provide the container id because each aggregate repository needs a slightly different configuration and therefore needs its own config key.Note: You can have a look at the ProophTest\\EventStore\\Mock\\RepositoryMockFactory. It sounds more complex than it is.Let's say we have a repository factory for a User aggregate root. We use user_repository as container id and add this configuration to our application configuration:[ 'prooph' =&gt; [ 'event_sourcing' =&gt; [ 'aggregate_repository' =&gt; [ 'user_repository' =&gt; [ \/\/&lt;-- here the container id is referenced 'repository_class' =&gt; MyUserRepository::class, \/\/&lt;-- FQCN of the repository responsible for the aggregate root 'aggregate_type' =&gt; MyUser::class, \/\/&lt;-- The aggregate root FQCN the repository is responsible for 'aggregate_translator' =&gt; 'user_translator', \/\/&lt;-- The aggregate translator must be available as service in the container ], ], ], ], ] If you want to speed up loading of aggregates with a snapshot store then you need to make it available as service in the container and use the configuration to let the factory inject the snapshot store in the repository.Also you need to install Prooph SnapshotStore and a persistable implementation of it, like pdo-snapshot-store or mongodb-snapshot-store.[ 'prooph' =&gt; [ 'event_sourcing' =&gt; [ 'aggregate_repository' =&gt; [ 'user_repository' =&gt; [ 'repository_class' =&gt; MyUserRepository::class, 'aggregate_type' =&gt; MyUser::class, 'aggregate_translator' =&gt; 'user_translator', 'snapshot_store' =&gt; 'awesome_snapshot_store' \/\/ &lt;-- SnapshotStore service id ], ], ], ], \/\/ zf3 service manager example to configure snapshot store service below 'dependencies' =&gt; [ 'aliases' =&gt; [ 'awesome_snapshot_store' =&gt; InMemorySnaphotStore::class, ], 'factories' =&gt; [ InMemorySnaphotStore::class =&gt; InvokableFactory::class, ], ], ] You can also configure a custom stream name (default is event_stream):[ 'prooph' =&gt; [ 'event_sourcing' =&gt; [ 'aggregate_repository' =&gt; [ 'user_repository' =&gt; [ 'repository_class' =&gt; MyUserRepository::class, 'aggregate_type' =&gt; MyUser::class, 'aggregate_translator' =&gt; 'user_translator', 'snapshot_store' =&gt; 'awesome_snapshot_store', \/\/ &lt;-- SnapshotStore service id 'stream_name' =&gt; 'user_stream' \/\/ &lt;-- Custom stream name ], ], ], ], ] Last but not least you can enable the so called \"One-Stream-Per-Aggregate-Mode\":[ 'prooph' =&gt; [ 'event_sourcing' =&gt; [ 'aggregate_repository' =&gt; [ 'user_repository' =&gt; [ 'repository_class' =&gt; MyUserRepository::class, 'aggregate_type' =&gt; MyUser::class, 'aggregate_translator' =&gt; 'user_translator', 'snapshot_store' =&gt; 'awesome_snapshot_store', \/\/ &lt;-- SnapshotStore service id 'one_stream_per_aggregate' =&gt; true \/\/ &lt;-- Enable One-Stream-Per-Aggregate-Mode ], ], ], ], ] "},{"id":"\/docs\/html\/event-sourcing\/migration.html#4-6-1","title":"Aggregate Repository","content":"The aggregate repository has a new method saveAggregateRoot($aggregateRoot) which replaces the addAggregateRoot($aggregateRoot) method. Additionally this method has to be called everytime you change an aggregate root, so if you're working with the command bus, you have to update all your handlers and call saveAggregateRoot everywhere.Reason: In the past the aggregate root was automatically updated with the aggregate repository due to the EventStore::commit event hook. The event store does not implement the commit method in all cases now, only the ones implementing the Prooph\\EventStore\\TransactionalEventStore interface. Also not all event stores are needed to trigger action events. Only the ones that are wrapped by Prooph\\EventStore\\ActionEventEmitterEventStore or Prooph\\EventStore\\TransactionalActionEventEmitterEventStore. In order for the repositories to work in all scenarios (where you can also change the used event store implementation in your app) this behaviour has been removed and you always have to call saveAggregateRoot($aggregateRoot) on the aggregate repository yourself."},{"id":"\/docs\/html\/event-sourcing\/migration.html#4-6-2","title":"Moved classes","content":"The classes Prooph\\EventStore\\Aggregate\\* are moved from the event-store repository to the event-sourcing repository. Hence the new class name Prooph\\EventSourcing\\Aggregate\\*. This includes the AggregateRepository, AggregateTranslator, AggregateType and AggregateTypeProvider as well as some exception classes.Same goes for Prooph\\EventStore\\Snapshot\\* classes.Reason:The event-store should not know anything about event sourcing at all, it's only a mechanism to store a stream of events. Therefore all those classes are moved."},{"id":"\/docs\/html\/event-sourcing\/migration.html#4-6-3","title":"ConfigurableAggregateTranslator","content":"The ConfigurableAggregateTranslator was part of Prooph\\EventStore v6 and has been completely removed. If you want to use something similar (especially when you don't want to extend from Prooph\\EventSourcing\\AggregateRoot) then you can implement the Prooph\\EventSourcing\\Aggregate\\AggregateTranslator interface yourself."},{"id":"\/docs\/html\/event-sourcing\/migration.html#4-6-4","title":"Snapshot Store","content":"The snapshot store is now a simple interface, see Prooph\\SnapshotStore\\SnapshotStore. The adapters have all been removed and replaced with different snapshot store implementation, f.e. Prooph\\SnapshotStore\\InMemorySnapshotStore."},{"id":"\/docs\/html\/event-sourcing\/migration.html#4-6-5","title":"Aggregate Root","content":"The method apply is now an abstract protected method. The old implementation was:protected function apply(AggregateChanged $e) { $handler = $this-&gt;determineEventHandlerMethodFor($e); if (! method_exists($this, $handler)) { throw new \\RuntimeException(sprintf( 'Missing event handler method %s for aggregate root %s', $handler, get_class($this) )); } $this-&gt;{$handler}($e); } protected function determineEventHandlerMethodFor(AggregateChanged $e) { return 'when' . implode(array_slice(explode('\\\\', get_class($e)), -1)); } and is now replaced by simply:abstract protected function apply(AggregateChanged $e): void; If you want to old behaviour back, you have to implement this yourself.Reason: It's much more performant to have the apply method implemented like:protected function apply(AggregateChanged $e): void { if ($e instanceof Foo) { \/\/ do something } elseif ($e instance of Bar) { \/\/ do something else } else { throw new \\DomainException('Unknown event applied'); } } It's up to you which you prefer and hence there is no default implementation given anymore."}]