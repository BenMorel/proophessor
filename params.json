{"name":"proophessor","tagline":"CQRS + ES for ZF2","body":"# proophessor\r\n\r\nCQRS + ES for ZF2\r\n\r\n[![Build Status](https://travis-ci.org/prooph/proophessor.svg?branch=master)](https://travis-ci.org/prooph/proophessor)\r\n[![Coverage Status](https://coveralls.io/repos/prooph/proophessor/badge.svg?branch=master)](https://coveralls.io/r/prooph/proophessor?branch=master)\r\n\r\nProophessor combines [prooph/service-bus](https://github.com/prooph/service-bus), [proop/event-store](https://github.com/prooph/event-store) and [prooph/event-sourcing](https://github.com/prooph/event-sourcing) in a single ZF2 module to simplify the set up process for a full featured CQRS + ES system.\r\n\r\n## Key Facts\r\n- [x] CQRS messaging tools\r\n- [x] Event Store implementation\r\n- [x] Event Sourcing base classes\r\n- [x] Default configuration to get started in no time\r\n- [x] Automatic transaction handling\r\n  - handle command dispatch in a transaction\r\n  - link recorded events with causative command\r\n  - include synchronous dispatched events in transaction\r\n- [ ] Synchronous and asynchronous event dispatching\r\n  - [x] Sync dispatch: within the command transaction to make sure that read model is always up to date\r\n  - [ ] Async dispatch: the event store will act as a job queue so that multiple worker can pull events from it\r\n- [x] Common command and event objects to ease communication between prooph components and reduce translation overhead\r\n- [ ] Apigility support\r\n  - Messagebox endpoint for commands\r\n  - Read access to the event store\r\n- [ ] ZF2 developer toolbar integration\r\n  - monitor commands and recorded events\r\n  - replay event stream to a specific version\r\n- [ ] Snapshot functionality for aggregates\r\n \r\n## Apps Using Proophessor\r\n- [prooph LINK](https://github.com/prooph/link)\r\n\r\n## Example Application\r\n\r\nTry out [proophessor-do](https://github.com/prooph/proophessor-do) and [pick up a task](https://github.com/prooph/proophessor-do#learning-by-doing)!\r\n\r\n## Installation\r\n\r\n### Proophessor Module\r\nOf course proophessor is available on packagist. Simply add `\"prooph/proophessor\" : \"~0.1\"` to your composer.json.\r\nAs this is a ZF2 Module you need to enable it in your `application.config.php` with the module name `Prooph\\Proophessor`.\r\n\r\n### Event Store Schema\r\n\r\nBy default proophessor connects to a RDBMS using the [doctrine adapter](https://github.com/prooph/event-store-doctrine-adapter) for prooph/event-store.\r\nThe [stream strategy](https://github.com/prooph/event-store#streamstrategies) defaults to a SingleStreamStrategy using a table called `proophessor_event_stream`.\r\nThere are two ways available to create this table:\r\n\r\n#### Using Doctrine Migrations\r\n\r\nThe recommended way is to use doctrine migrations. Therefor you need to install the [doctrine-orm-module](https://github.com/doctrine/DoctrineORMModule)\r\nand use the appropriate CLI commands of the module to create and run migrations.\r\nProophessor ships with a `EventStoreSchema` class which you can use in a migrations script to set up the event stream table.\r\n\r\n```php\r\n<?php\r\n\r\nnamespace Application\\Migrations;\r\n\r\nuse Doctrine\\DBAL\\Migrations\\AbstractMigration,\r\n    Doctrine\\DBAL\\Schema\\Schema;\r\nuse Prooph\\Proophessor\\Schema\\EventStoreSchema;\r\n\r\n/**\r\n * Auto-generated Migration: Please modify to your need!\r\n */\r\nclass Version20150429205328 extends AbstractMigration\r\n{\r\n    public function up(Schema $schema)\r\n    {\r\n        EventStoreSchema::createSchema($schema);\r\n    }\r\n\r\n    public function down(Schema $schema)\r\n    {\r\n        EventStoreSchema::dropSchema($schema);\r\n    }\r\n}\r\n```\r\n\r\n#### Using SQL\r\n\r\nIf you don't want to use doctrine migrations or doctrine at all (there are also other event store adapters available)\r\nyou can use the SQL located in the `scripts` folder to create the event stream table manually.\r\n\r\n## Configuration\r\n\r\nAs a ZF2 dev you should be familiar with the way of configuring things in a ZF2 application. The module groups everything\r\nrelated to the CQRS + ES infrastructure under the root config key `proophessor`.\r\n\r\n### Event Store Adapter\r\n\r\nOne of the crucial configuration points is the database connection for the event store. Proophessor assumes that you have\r\na doctrine connection defined called `orm_default`, because this is the default when using the doctrine-orm-module\r\nmentioned above. However, you can override the default with a dedicated connection or even another adapter for the event store:\r\n\r\n#### Configure Own Doctrine Adapter Connection\r\n```php\r\n<?php\r\n//In your own module.config.php or in the application autoload/local.php\r\nreturn [\r\n    'proophessor' => [\r\n        'event_store' => [\r\n            'adapter' => [\r\n                'options' => [\r\n                    'connection' => [\r\n                        'dbname' => 'my_db',\r\n                        'driver' => 'pdo_mysql',\r\n                        'host' => 'localhost',\r\n                        'user' => 'root',\r\n                        'charset' => 'utf8',\r\n                    ]\r\n                ]\r\n            ]\r\n        ]\r\n    ]\r\n];\r\n```\r\n\r\n#### Use Another Doctrine Connection Alias\r\n\r\n```php\r\n<?php\r\n//In your own module.config.php or in the application autoload/local.php\r\nreturn [\r\n    'proophessor' => [\r\n        'event_store' => [\r\n            'adapter' => [\r\n                'options' => [\r\n                    'doctrine_connection_alias' => 'event_store_default'\r\n                ]\r\n            ]\r\n        ]\r\n    ]\r\n];\r\n```\r\n\r\n### Aggregate Repository\r\n\r\nProophessor ships with a [AbstractRepositoryFactory](src/EventStore/AbstractRepositoryFactory.php) which simplifies the\r\ninstantiation of a repository. As long as you use the defaults provided by proophessor you don't need to worry about stream\r\nstrategies or a translator for your aggregates. Just tell proophessor which repository class is responsible for which aggregate type.\r\n\r\n```php\r\n<?php\r\n//In your own module.config.php or in the application autoload/global.php\r\nreturn [\r\n    'proophessor' => [\r\n        'event_store' => [\r\n            'repository_map' => [\r\n                'my.aggregate_repository.alias' => [\r\n                    'repository_class' => MyAggregateRepository::class,\r\n                    'aggregate_type'   => MyAggregate::class,\r\n                ]\r\n            ]\r\n        ]\r\n    ]\r\n];\r\n```\r\n\r\nA configuration like shown above allows you to retrieve a repository from the service manager:\r\n\r\n```php\r\n<?php\r\n//Somewhere in a command handler factory ...\r\n$myAggregateRepository = $serviceLocator->get('my.aggregate_repository.alias');\r\n```\r\n\r\n### Event Store Features\r\n\r\nto be defined ....\r\n\r\n### Service Bus Utils\r\n\r\nCommand/event bus utilities like a custom invoke strategy or a logger can be added via configuration.\r\nCheckout the [module.config.php](config/module.config.php) for details.\r\n\r\n### Command Routing\r\n\r\nThe command bus is set up with a [CommandRouter](https://github.com/prooph/service-bus/blob/master/docs/plugins.md#proophservicebusroutercommandrouter).\r\nThe routing map can be defined in the configuration. Checkout the [module.config.php](config/module.config.php) for details.\r\n\r\n### Event Routing\r\n\r\nThe event bus is set up with a [EventRouter](https://github.com/prooph/service-bus/blob/master/docs/plugins.md#proophservicebusroutereventrouter).\r\nThe routing map can be defined in the configuration. Checkout the [module.config.php](config/module.config.php) for details.\r\n\r\n\r\n## Registered Services\r\n\r\n### Retrieving The EventStore\r\n\r\nThe ProophEventStore can be retrieved from the service manager by using the alias `proophessor.event_store`.\r\n\r\n### Retrieving The CommandBus\r\n\r\nThe ProophServiceBus command bus can be retrieved from the service manager by using the alias `proophessor.command_bus`.\r\n\r\n### Retrieving The EventBus\r\n\r\nThe ProophServiceBus event bus can be retrieved from the service manager by using the alias `proophessor.event_bus`.\r\n\r\n## Working With The Command Bus\r\n\r\nThe command bus is the gate to the domain model. It is a rule of thumb to not use domain classes outside of the model.\r\nThe domain model should be protected by an application layer with a well defined API of actions that can be triggered in the\r\ndomain model. In CQRS the application API is defined through commands which are messages (like DTOs) with a specific intention.\r\nThe command bus is responsible for dispatching these commands to so called command handlers. Each command should have exactly one\r\ncommand handler and each command handler should only handle one command (1:1 relationship).\r\nIn a proophessor system you define such a connection with a `command_router_map` in the application configuration.\r\n\r\n```php\r\n<?php\r\n//In your own module.config.php or in the application autoload/global.php\r\nreturn [\r\n    'proophessor' => [\r\n        'command_router_map' => [\r\n            \\Application\\Model\\Command\\RegisterUser::class => \\Application\\Model\\User\\RegisterUserHandler::class,\r\n        ],\r\n    ];\r\n```\r\n\r\nThe target of the command (RegisterUserHandler::class in the example) should be a service name known by the service manager.\r\nCommand handlers are only instantiated when an appropriate command is dispatched (lazy loading), so you can define hundreds\r\nof commands and command handlers in your application without worrying about performance issues caused by heavy object creation.\r\n\r\n```php\r\n<?php\r\n//In your own module.config.php or in the application autoload/global.php\r\nreturn [\r\n    'service_manager' =>[\r\n        'factories' => [\r\n            \\Application\\Model\\User\\RegisterUserHandler::class => \\Application\\Infrastructure\\HandlerFactory\\RegisterUserHandlerFactory::class,\r\n        ],\r\n    ];\r\n```\r\n\r\nIn our example above we use the PHP 5.5 class constant feature to define the class name of the `RegisterUserHandler` as service name\r\nand map it to a factory which is responsible to instantiate a `RegisterUserHandler` object. But again, the factory is only invoked when\r\na `RegisterUser` command is dispatched by the command bus.\r\n\r\n### Command\r\n\r\nAll commands should extend `Prooph\\Common\\Messaging\\Command`. The `RegisterUser` command would look something like this:\r\n\r\n```php\r\n<?php\r\nnamespace Application\\Model\\Command;\r\n\r\nuse Application\\Model\\User\\EmailAddress;\r\nuse Application\\Model\\User\\UserId;\r\nuse Prooph\\Common\\Messaging\\Command;\r\n\r\nfinal class RegisterUser extends Command\r\n{\r\n    /**\r\n     * @param string $userId\r\n     * @param string $name\r\n     * @param string $email\r\n     * @return RegisterUser\r\n     */\r\n    public static function withData($userId, $name, $email)\r\n    {\r\n        return new self(__CLASS__, [\r\n            'user_id' => (string)$userId,\r\n            'name' => (string)$name,\r\n            'email' => (string)$email\r\n        ]);\r\n    }\r\n\r\n    /**\r\n     * @return UserId\r\n     */\r\n    public function userId()\r\n    {\r\n        return UserId::fromString($this->payload['user_id']);\r\n    }\r\n\r\n    /**\r\n     * @return string\r\n     */\r\n    public function name()\r\n    {\r\n        return $this->payload['name'];\r\n    }\r\n\r\n    /**\r\n     * @return EmailAddress\r\n     */\r\n    public function emailAddress()\r\n    {\r\n        return EmailAddress::fromString($this->payload['email']);\r\n    }\r\n}\r\n```\r\n\r\nWe use a named constructor to instantiate the command. The method takes only native PHP types as arguments.\r\nThis is due to the fact that the command is instantiated in userland code (for example a controller). In userland code\r\nour domain model classes should not be used or even not be known.\r\n\r\n\r\nThe first argument of the class constructor is the name of the command. We use the class as command name but you could\r\nalso use another name if you don't want your command name look like a PHP namespace.\r\n\r\n\r\nThe second argument is a payload array. It is later used in the getter methods to instantiate value objects from it if\r\nrequired by the model.\r\n\r\n\r\n`The payload should only contain scalar types and arrays` because only these types allow\r\na secure way to convert a command to a remote message which can be send to a remote system or pushed on a job queue.\r\nProophessor doesn't work with serializers or annotations to help you with type mapping, because they slow down the system\r\nand add complexity.\r\n\r\n### Command Flow\r\n\r\nA command is normally dispatched from inside a MVC controller action or a process manager (when an domain event causes a follow up command).\r\nDispatching a command is relatively simple:\r\n\r\n```php\r\n<?php\r\nclass UserRegistrationController extends AbstractActionController\r\n{\r\n    //The user id is generated by the controller, so that we can provide the client with\r\n    //the identifier to request the user data after registration\r\n    $userId = Uuid::uuid4()->toString();\r\n\r\n    //We skip validation in the example for the sake of simplicity\r\n    $command = RegisterUser::withData(\r\n        $userId,\r\n        $this->params()->fromPost('username'),\r\n        $this->params()->fromPost('email')\r\n    );\r\n\r\n    //We directly access the service manager in the example for the sake of simplicity\r\n    $this->getServiceLocator()->get('proophessor.command_bus')->dispatch($command);\r\n\r\n    //When dispatching a command you get no response from the command bus except an exception is thrown!\r\n    //The client has to request the user data from the read model\r\n    return ['user_id' => $userId];\r\n}\r\n```\r\n\r\nLike already mentioned the receiver of such a command should always be a command handler implementing a `handle` method:\r\n\r\n```php\r\n<?php\r\nnamespace Application\\Model\\User;\r\n\r\nuse Application\\Model\\Command\\RegisterUser;\r\n\r\nfinal class RegisterUserHandler\r\n{\r\n    /**\r\n     * @var UserCollection\r\n     */\r\n    private $userCollection;\r\n\r\n    /**\r\n     * @param UserCollection $userCollection\r\n     */\r\n    public function __construct(UserCollection $userCollection)\r\n    {\r\n        $this->userCollection = $userCollection;\r\n    }\r\n\r\n    /**\r\n     * @param RegisterUser $command\r\n     */\r\n    public function handle(RegisterUser $command)\r\n    {\r\n        $user = User::registerWithData($command->userId(), $command->name(), $command->emailAddress());\r\n\r\n        $this->userCollection->add($user);\r\n    }\r\n}\r\n```\r\n\r\n## Domain Model\r\n\r\nProophessor ships with [prooph/event-sourcing](https://github.com/prooph/event-sourcing) which turns your entities into\r\nevent sourced aggregate roots. You should follow two rules so that proophessor is able to handle your aggregate roots correctly.\r\n\r\n1. All aggregate roots should extend `Prooph\\EventSourcing\\AggregateRoot` and implement the protected function `AggregateRoot::aggregateId`\r\n2. All aggregate root domain events should extend `Prooph\\EventSourcing\\AggregateChanged` which inherits from `Prooph\\Common\\Messaging\\DomainEvent`.\r\n\r\n### Aggregate Root\r\n\r\n```php\r\n<?php\r\nnamespace Application\\Model\\User;\r\n\r\nuse Assert\\Assertion;\r\nuse Prooph\\EventSourcing\\AggregateRoot;\r\n\r\nfinal class User extends AggregateRoot\r\n{\r\n    /**\r\n     * @var UserId\r\n     */\r\n    private $userId;\r\n\r\n    /**\r\n     * @var string\r\n     */\r\n    private $name;\r\n\r\n    /**\r\n     * @var EmailAddress\r\n     */\r\n    private $emailAddress;\r\n\r\n    /**\r\n     * @param UserId $userId\r\n     * @param string $name\r\n     * @param EmailAddress $emailAddress\r\n     * @return User\r\n     */\r\n    public static function registerWithData(UserId $userId, $name, EmailAddress $emailAddress)\r\n    {\r\n        $self = new self();\r\n\r\n        $self->assertName($name);\r\n\r\n        $self->recordThat(UserWasRegistered::withData($userId, $name, $emailAddress));\r\n\r\n        return $self;\r\n    }\r\n\r\n    /**\r\n     * @return UserId\r\n     */\r\n    public function userId()\r\n    {\r\n        return $this->userId;\r\n    }\r\n\r\n    /**\r\n     * @return string\r\n     */\r\n    public function name()\r\n    {\r\n        return $this->name;\r\n    }\r\n\r\n    /**\r\n     * @return EmailAddress\r\n     */\r\n    public function emailAddress()\r\n    {\r\n        return $this->emailAddress;\r\n    }\r\n\r\n    /**\r\n     * @return string representation of the unique identifier of the aggregate root\r\n     */\r\n    protected function aggregateId()\r\n    {\r\n        return $this->userId->toString();\r\n    }\r\n\r\n    /**\r\n     * @param UserWasRegistered $event\r\n     */\r\n    protected function whenUserWasRegistered(UserWasRegistered $event)\r\n    {\r\n        $this->userId = $event->userId();\r\n        $this->name = $event->name();\r\n        $this->emailAddress = $event->emailAddress();\r\n    }\r\n\r\n    /**\r\n     * @param string $name\r\n     * @throws InvalidName\r\n     */\r\n    private function assertName($name)\r\n    {\r\n        try {\r\n            Assertion::string($name);\r\n            Assertion::notEmpty($name);\r\n        } catch (\\Exception $e) {\r\n            throw InvalidName::reason($e->getMessage());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nAn event sourced aggregate root looks different from entities you may have used in the past. `Prooph\\EventSourcing\\AggregateRoot`\r\nforces implementers to provide at least one named constructor like the `User::registerWithData` method shown in the example.\r\nSuch a named constructor should then invoke the class constructor without any arguments and then record the first\r\ndomain event of the aggregate root. Internally the new event is added to the list of pending events (waiting to be stored in the event stream on transaction commit)\r\nand then forwarded to a special setter method which has the naming convention `when<ShortEventName>`. In the example it is the method\r\n`User::whenUserWasRegistered`. Object properties should be first set in such a domain event setter method because the setter is also used later when reconstituting\r\nthe aggregate root. Methods changing the state of the aggregate root should work in a similar way:\r\n\r\n1. Assert that changes can be made\r\n2. Record new domain event which indicates the changes\r\n3. Use a domain event setter method to adopt the changes\r\n\r\n### AggregateChanged Domain Event\r\n\r\n```php\r\n<?php\r\nnamespace Application\\Model\\User;\r\n\r\nuse Assert\\Assertion;\r\nuse Prooph\\EventSourcing\\AggregateChanged;\r\nuse Prooph\\Proophessor\\EventStore\\IsProcessedAsync;\r\n\r\nfinal class UserWasRegistered extends AggregateChanged\r\n{\r\n    private $userId;\r\n\r\n    private $username;\r\n\r\n    private $emailAddress;\r\n\r\n    /**\r\n     * @param UserId $userId\r\n     * @param string $name\r\n     * @param EmailAddress $emailAddress\r\n     * @return UserWasRegistered\r\n     */\r\n    public static function withData(UserId $userId, $name, EmailAddress $emailAddress)\r\n    {\r\n        Assertion::string($name);\r\n\r\n        $event = self::occur($userId->toString(), [\r\n            'name' => $name,\r\n            'email' => $emailAddress->toString(),\r\n        ]);\r\n\r\n        $event->userId = $userId;\r\n        $event->username = $name;\r\n        $event->emailAddress = $emailAddress;\r\n\r\n        return $event;\r\n    }\r\n\r\n    /**\r\n     * @return UserId\r\n     */\r\n    public function userId()\r\n    {\r\n        if (is_null($this->userId)) {\r\n            $this->userId = UserId::fromString($this->aggregateId);\r\n        }\r\n        return $this->userId;\r\n    }\r\n\r\n    /**\r\n     * @return string\r\n     */\r\n    public function name()\r\n    {\r\n        if (is_null($this->username)) {\r\n            $this->username = $this->payload['name'];\r\n        }\r\n        return $this->username;\r\n    }\r\n\r\n    /**\r\n     * @return EmailAddress\r\n     */\r\n    public function emailAddress()\r\n    {\r\n        if (is_null($this->emailAddress)) {\r\n            $this->emailAddress = EmailAddress::fromString($this->payload['email']);\r\n        }\r\n        return $this->emailAddress;\r\n    }\r\n}\r\n```\r\n\r\nThe AggregateChanged class inherits from `Prooph\\Common\\Messaging\\DomainEvent` which has the same base class as\r\n`Prooph\\Common\\Messaging\\Command` namely `Prooph\\Common\\Messaging\\DomainMessage`. Other than a command the named\r\nconstructor of an AggregateChanged domain event should take value objects of the domain model as arguments whenever possible.\r\nAs you can see in the example we use some kind of object caching to avoid object creation of the value objects when the getter methods\r\nare called.\r\n\r\n\r\n`But why can't we simply pass the value objects to the payload?` The answer is the same as for commands.\r\nProophessor doesn't use serializers or other type mapping techniques. The payload of a domain event is just `json_encode`d when\r\nstoring it in the event store or dispatching it to a remote system. `So the payload should only contain scalar values or arrays!`\r\nIt is your job to convert your value objects into native PHP types and back. Proophessor can't know the structure of your value objects\r\nand we don't want to rely on generic mapping. It simplifies things in the first place but sooner or later you would run into trouble with it\r\nor encounter performance bottlenecks. Some seconds more work when coding the classes will save you a lot of headache later!\r\n\r\n\r\nThe AggregateChanged class provides a named constructor which should be used internally: `AggregateChanged::occur`.\r\nFirst argument of the method should be the identifier of the related aggregate root given as a string. Second argument is the\r\nalready mentioned payload. The message name of a AggregateChanged domain event defaults to the class name of the implementing class.\r\nHowever, you can change the name by setting the `name` property of the event to another value after instantiation.\r\n\r\n## Working With Repositories\r\n\r\nEach aggregate root should have a corresponding repository. Proophessor works with `collection like repositories` that means\r\nyou don't have to call save, persist or a similar method on the repository. Just add a aggregate root to its collection repository\r\nand retrieve it later when you need to trigger changes on the aggregate root.\r\nIt is a common practice to define an interface for each repository in your domain model but put the implementation in the infrastructure\r\nbecause the implementation is connected to a data storage (in our case the event store) which should not leak into the domain model.\r\nA typical repository interface looks like the following:\r\n\r\n```php\r\n<?php\r\nnamespace Application\\Model\\User;\r\n\r\ninterface UserCollection\r\n{\r\n    /**\r\n     * @param User $user\r\n     * @return void\r\n     */\r\n    public function add(User $user);\r\n\r\n    /**\r\n     * @param UserId $userId\r\n     * @return User\r\n     */\r\n    public function get(UserId $userId);\r\n}\r\n```\r\n\r\nAnd this is the corresponding implementation using `Prooph\\EventStore\\Aggregate\\AggregateRepository`:\r\n\r\n```php\r\n<?php\r\nnamespace Application\\Infrastructure\\Repository;\r\n\r\nuse Application\\Model\\User\\User;\r\nuse Application\\Model\\User\\UserCollection;\r\nuse Application\\Model\\User\\UserId;\r\nuse Prooph\\EventStore\\Aggregate\\AggregateRepository;\r\n\r\nfinal class EventStoreUserCollection extends AggregateRepository implements UserCollection\r\n{\r\n    /**\r\n     * @param User $user\r\n     * @return void\r\n     */\r\n    public function add(User $user)\r\n    {\r\n        $this->addAggregateRoot($user);\r\n    }\r\n\r\n    /**\r\n     * @param UserId $userId\r\n     * @return User\r\n     */\r\n    public function get(UserId $userId)\r\n    {\r\n        return $this->getAggregateRoot($userId->toString());\r\n    }\r\n}\r\n```\r\n\r\nEasy, isn't it?\r\n\r\nHow you can configure proophessor to provide you with such a repository is explained in the [configuration](#aggregate-repository) section.\r\n\r\n## Working With The Event Bus\r\n\r\nNormally you don't need to interact with the event bus directly. Just add event handlers to the `event_router_map` like described in the [configuration](#event-routing) section.\r\nLike command handlers event handlers are only instantiated when an event is dispatched to a interested handler.\r\nOne event can have many event handlers. Therefor the `event_routing_map` defines a 1:n connection:\r\n\r\n```php\r\n<?php\r\n//In your own module.config.php or in the application autoload/global.php\r\nreturn [\r\n    'proophessor' => [\r\n        'event_router_map' => [\r\n            \\Application\\Model\\User\\UserWasRegistered::class => [\r\n                \\Application\\Projection\\User\\UserProjector::class,\r\n            ]\r\n        ],\r\n    ];\r\n```\r\n\r\nAlso in this case we use the PHP 5.5 class constant feature to define the class name of the UserProjector as a service name\r\nso that the event bus can retrieve the UserProjector from the service manager.\r\n\r\n```php\r\n<?php\r\n//In your own module.config.php or in the application autoload/global.php\r\nreturn [\r\n    'service_manager' => [\r\n        'factories' => [\r\n            \\Application\\Model\\User\\RegisterUserHandler::class => \\Application\\Infrastructure\\HandlerFactory\\RegisterUserHandlerFactory::class,\r\n            \\Application\\Projection\\User\\UserProjector::class => \\Application\\Projection\\User\\UserProjectorFactory::class,\r\n        ],\r\n    ];\r\n```\r\n\r\n### Handle Domain Events\r\n\r\nEvent handlers should implement a method for each event they are interested in. The convention for such a handle method is `on<ShortEventName>`.\r\nCheckout the read model projection example below.\r\n\r\n## Read Model Projection\r\n\r\nProophessor doesn't provide a specific read model implementation. It is up to you to implement it. The read model\r\nshould be as simple as possible. It is so called `throw away code` because all important information is stored in form of\r\ndomain events in the event store. The read model can be regenerated at any time and in any form you need it to let your\r\napplication respond fast!\r\n\r\nThe example shows a simple read model projection using a `Doctrine\\DBAL\\Connection` to persist the user data in a relational\r\ndatabase table. By default the event store and the read model share the same database. However, if you need more performance or\r\nscalability you can use different storage mechanisms for the event store and the read model.\r\n\r\n```php\r\n<?php\r\nnamespace Application\\Projection\\User;\r\n\r\nuse Application\\Model\\User\\UserWasRegistered;\r\nuse Application\\Projection\\Table;\r\nuse Doctrine\\DBAL\\Connection;\r\n\r\nfinal class UserProjector\r\n{\r\n    /**\r\n     * @var Connection\r\n     */\r\n    private $connection;\r\n\r\n\r\n    /**\r\n     * @param Connection $connection\r\n     */\r\n    public function __construct(Connection $connection)\r\n    {\r\n        $this->connection = $connection;\r\n    }\r\n\r\n    /**\r\n     * @param UserWasRegistered $event\r\n     */\r\n    public function onUserWasRegistered(UserWasRegistered $event)\r\n    {\r\n        $this->connection->insert(Table::USER, [\r\n            'id' => $event->userId()->toString(),\r\n            'name' => $event->name(),\r\n            'email' => $event->emailAddress()->toString()\r\n        ]);\r\n    }\r\n}\r\n```\r\n\r\n### Transaction Handling\r\n\r\nProophessor automatically handles transactions for you. Each time you dispatch a command a new transaction is started.\r\nA successful dispatch commits the transaction and an error causes a rollback. `Proophessor only opens one transaction.`\r\nIf you work with a process manager which listens on synchronous dispatched events and the process manager dispatches\r\nfollow up commands, these commands are handled `in the same transaction as the first command`. If a follow up command fails\r\nthe transaction is completely rolled back including `all recorded events` and potential `changes in the read model`.\r\nAgain, this only happens if your events are dispatched `synchronous` and if the event store and the read model `share the same\r\ndatabase connection`.\r\n\r\nThe TransactionManager is responsible for handling these scenarios. It makes use of the action event systems provided by\r\nprooph/service-bus and prooph/event-store to seamlessly integrate transaction handling.\r\n\r\n#### Begin, Commit, Rollback\r\nThe TransactionManager registers a listener on the `Prooph\\ServiceBus\\Process\\CommandDispatch::INITIALIZE` action event with a low\r\npriority of `-1000` to begin a new transaction if no one is already started and only if the command extends `Prooph\\Common\\Messaging\\Command` and\r\ndoes not implement `Prooph\\Proophessor\\EventStore\\AutoCommitCommand`. The latter is a marker interface to tell the TransactionManager that it\r\nshould ignore such a command and all domain events caused by it.\r\n\r\nFurthermore, the TransactionManager registers a listener on the `Prooph\\ServiceBus\\Process\\CommandDispatch::FINALIZE` action event with a high\r\npriority of `1000`. In the listener the TransactionManager decides either if it commits the current transaction or if it performs a rollback\r\ndepending on the current CommandDispatch.\r\n\r\nA rollback is performed if `CommandDispatch::getException` returns a caught exception. With that in mind you\r\ncan influence the rollback behaviour by registering an own listener on `Prooph\\ServiceBus\\Process\\CommandDispatch::ERROR`, handle a caught exception of\r\nyour own (f.e. retry current command, translate exception into DomainEvent, etc.) and unset the exception in the CommandDispatch by invoking\r\n`CommandDispatch::setException` with `NULL` as argument.\r\n\r\nIf the TransactionManager has an active transaction and no exception was caught during dispatch (or was unset) the transaction gets committed.\r\n\r\n#### Event Dispatch and Status\r\nThe TransactionManager has a second job which is related to handling the transaction. It adds meta information to each recorded domain event\r\nnamely the UUID of the current command - referenced as `causation_id`, the message name of the current command - referenced as `causation_name` and\r\na `dispatch_status`. The latter can either be `0 = event dispatch not started` or `2 = event dispatch was successful`.\r\n\r\nTo determine the dispatch status of a domain event the TransactionManager checks if the recorded event should be dispatched synchronous or\r\nasynchronous based on the marker interface: `Prooph\\Proophessor\\EventStore\\IsProcessedAsync`.\r\n\r\nAll synchronous domain events are forwarded to the EventBus by the TransactionManager and the dispatch status is set to `2`\r\n(a failing event dispatch causes a transaction rollback, so that status will never be set for sync events).\r\n\r\nFor all asynchronous domain events the dispatch status is set to `0` and they are not forwarded to the EventBus!\r\n\r\n\r\nSupport\r\n-------\r\n\r\n- Ask questions on [prooph-users](https://groups.google.com/forum/?hl=de#!forum/prooph) google group.\r\n- File issues at [https://github.com/prooph/proophessor/issues](https://github.com/prooph/proophessor/issues).\r\n\r\n\r\nContribute\r\n----------\r\n\r\nPlease feel free to fork and extend existing or add new features and send a pull request with your changes!\r\nTo establish a consistent code quality, please provide unit tests for all your changes and may adapt the documentation.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}